// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn parse_generic_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<smithy_types::Error, serde_json::Error> {
    let body =
        serde_json::from_slice(response.body().as_ref()).unwrap_or_else(|_| serde_json::json!({}));
    Ok(crate::aws_json_errors::parse_generic_error(
        &response, &body,
    ))
}

pub fn bad_gateway_exception(
    inp: &[u8],
    mut builder: crate::error::bad_gateway_error::Builder,
) -> Result<crate::error::bad_gateway_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::BadGatewayError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn bad_request_exception(
    inp: &[u8],
    mut builder: crate::error::bad_request_error::Builder,
) -> Result<crate::error::bad_request_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::BadRequestError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn conflict_exception(
    inp: &[u8],
    mut builder: crate::error::conflict_error::Builder,
) -> Result<crate::error::conflict_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ConflictError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn forbidden_exception(
    inp: &[u8],
    mut builder: crate::error::forbidden_error::Builder,
) -> Result<crate::error::forbidden_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ForbiddenError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn gateway_timeout_exception(
    inp: &[u8],
    mut builder: crate::error::gateway_timeout_error::Builder,
) -> Result<crate::error::gateway_timeout_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::GatewayTimeoutError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn internal_server_error_exception(
    inp: &[u8],
    mut builder: crate::error::internal_server_error_error::Builder,
) -> Result<crate::error::internal_server_error_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InternalServerErrorError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn not_found_exception(
    inp: &[u8],
    mut builder: crate::error::not_found_error::Builder,
) -> Result<crate::error::not_found_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::NotFoundError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn too_many_requests_exception(
    inp: &[u8],
    mut builder: crate::error::too_many_requests_error::Builder,
) -> Result<crate::error::too_many_requests_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::TooManyRequestsError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn unprocessable_entity_exception(
    inp: &[u8],
    mut builder: crate::error::unprocessable_entity_error::Builder,
) -> Result<crate::error::unprocessable_entity_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::UnprocessableEntityError = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_message(parsed_body.message);
    builder = builder.set_validation_errors(parsed_body.validation_errors);
    Ok(builder)
}

pub fn batch_delete_deser_operation(
    inp: &[u8],
    mut builder: crate::output::batch_delete_output::Builder,
) -> Result<crate::output::batch_delete_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::BatchDeleteOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_failed(parsed_body.failed);
    builder = builder.set_successful(parsed_body.successful);
    Ok(builder)
}

pub fn batch_start_deser_operation(
    inp: &[u8],
    mut builder: crate::output::batch_start_output::Builder,
) -> Result<crate::output::batch_start_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::BatchStartOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_failed(parsed_body.failed);
    builder = builder.set_successful(parsed_body.successful);
    Ok(builder)
}

pub fn batch_stop_deser_operation(
    inp: &[u8],
    mut builder: crate::output::batch_stop_output::Builder,
) -> Result<crate::output::batch_stop_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::BatchStopOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_failed(parsed_body.failed);
    builder = builder.set_successful(parsed_body.successful);
    Ok(builder)
}

pub fn batch_update_schedule_deser_operation(
    inp: &[u8],
    mut builder: crate::output::batch_update_schedule_output::Builder,
) -> Result<crate::output::batch_update_schedule_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::BatchUpdateScheduleOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_creates(parsed_body.creates);
    builder = builder.set_deletes(parsed_body.deletes);
    Ok(builder)
}

pub fn create_channel_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_channel_output::Builder,
) -> Result<crate::output::create_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateChannelOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_channel(parsed_body.channel);
    Ok(builder)
}

pub fn create_input_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_input_output::Builder,
) -> Result<crate::output::create_input_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateInputOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_input(parsed_body.input);
    Ok(builder)
}

pub fn create_input_security_group_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_input_security_group_output::Builder,
) -> Result<crate::output::create_input_security_group_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateInputSecurityGroupOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_security_group(parsed_body.security_group);
    Ok(builder)
}

pub fn create_multiplex_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_multiplex_output::Builder,
) -> Result<crate::output::create_multiplex_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateMultiplexOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_multiplex(parsed_body.multiplex);
    Ok(builder)
}

pub fn create_multiplex_program_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_multiplex_program_output::Builder,
) -> Result<crate::output::create_multiplex_program_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateMultiplexProgramOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_multiplex_program(parsed_body.multiplex_program);
    Ok(builder)
}

pub fn create_partner_input_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_partner_input_output::Builder,
) -> Result<crate::output::create_partner_input_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreatePartnerInputOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_input(parsed_body.input);
    Ok(builder)
}

pub fn delete_channel_deser_operation(
    inp: &[u8],
    mut builder: crate::output::delete_channel_output::Builder,
) -> Result<crate::output::delete_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteChannelOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_cdi_input_specification(parsed_body.cdi_input_specification);
    builder = builder.set_channel_class(parsed_body.channel_class);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_egress_endpoints(parsed_body.egress_endpoints);
    builder = builder.set_encoder_settings(parsed_body.encoder_settings);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_input_attachments(parsed_body.input_attachments);
    builder = builder.set_input_specification(parsed_body.input_specification);
    builder = builder.set_log_level(parsed_body.log_level);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipeline_details(parsed_body.pipeline_details);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_vpc(parsed_body.vpc);
    Ok(builder)
}

pub fn delete_multiplex_deser_operation(
    inp: &[u8],
    mut builder: crate::output::delete_multiplex_output::Builder,
) -> Result<crate::output::delete_multiplex_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteMultiplexOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_availability_zones(parsed_body.availability_zones);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_multiplex_settings(parsed_body.multiplex_settings);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_program_count(parsed_body.program_count);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn delete_multiplex_program_deser_operation(
    inp: &[u8],
    mut builder: crate::output::delete_multiplex_program_output::Builder,
) -> Result<crate::output::delete_multiplex_program_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteMultiplexProgramOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_channel_id(parsed_body.channel_id);
    builder = builder.set_multiplex_program_settings(parsed_body.multiplex_program_settings);
    builder = builder.set_packet_identifiers_map(parsed_body.packet_identifiers_map);
    builder = builder.set_pipeline_details(parsed_body.pipeline_details);
    builder = builder.set_program_name(parsed_body.program_name);
    Ok(builder)
}

pub fn delete_reservation_deser_operation(
    inp: &[u8],
    mut builder: crate::output::delete_reservation_output::Builder,
) -> Result<crate::output::delete_reservation_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteReservationOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_count(parsed_body.count);
    builder = builder.set_currency_code(parsed_body.currency_code);
    builder = builder.set_duration(parsed_body.duration);
    builder = builder.set_duration_units(parsed_body.duration_units);
    builder = builder.set_end(parsed_body.end);
    builder = builder.set_fixed_price(parsed_body.fixed_price);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_offering_description(parsed_body.offering_description);
    builder = builder.set_offering_id(parsed_body.offering_id);
    builder = builder.set_offering_type(parsed_body.offering_type);
    builder = builder.set_region(parsed_body.region);
    builder = builder.set_reservation_id(parsed_body.reservation_id);
    builder = builder.set_resource_specification(parsed_body.resource_specification);
    builder = builder.set_start(parsed_body.start);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_usage_price(parsed_body.usage_price);
    Ok(builder)
}

pub fn describe_channel_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_channel_output::Builder,
) -> Result<crate::output::describe_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeChannelOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_cdi_input_specification(parsed_body.cdi_input_specification);
    builder = builder.set_channel_class(parsed_body.channel_class);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_egress_endpoints(parsed_body.egress_endpoints);
    builder = builder.set_encoder_settings(parsed_body.encoder_settings);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_input_attachments(parsed_body.input_attachments);
    builder = builder.set_input_specification(parsed_body.input_specification);
    builder = builder.set_log_level(parsed_body.log_level);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipeline_details(parsed_body.pipeline_details);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_vpc(parsed_body.vpc);
    Ok(builder)
}

pub fn describe_input_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_input_output::Builder,
) -> Result<crate::output::describe_input_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeInputOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_attached_channels(parsed_body.attached_channels);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_input_class(parsed_body.input_class);
    builder = builder.set_input_devices(parsed_body.input_devices);
    builder = builder.set_input_partner_ids(parsed_body.input_partner_ids);
    builder = builder.set_input_source_type(parsed_body.input_source_type);
    builder = builder.set_media_connect_flows(parsed_body.media_connect_flows);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_security_groups(parsed_body.security_groups);
    builder = builder.set_sources(parsed_body.sources);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_type(parsed_body.r#type);
    Ok(builder)
}

pub fn describe_input_device_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_input_device_output::Builder,
) -> Result<crate::output::describe_input_device_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeInputDeviceOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_connection_state(parsed_body.connection_state);
    builder = builder.set_device_settings_sync_state(parsed_body.device_settings_sync_state);
    builder = builder.set_device_update_status(parsed_body.device_update_status);
    builder = builder.set_hd_device_settings(parsed_body.hd_device_settings);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_mac_address(parsed_body.mac_address);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_network_settings(parsed_body.network_settings);
    builder = builder.set_serial_number(parsed_body.serial_number);
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_uhd_device_settings(parsed_body.uhd_device_settings);
    Ok(builder)
}

pub fn describe_input_security_group_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_input_security_group_output::Builder,
) -> Result<crate::output::describe_input_security_group_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeInputSecurityGroupOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_inputs(parsed_body.inputs);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_whitelist_rules(parsed_body.whitelist_rules);
    Ok(builder)
}

pub fn describe_multiplex_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_multiplex_output::Builder,
) -> Result<crate::output::describe_multiplex_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeMultiplexOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_availability_zones(parsed_body.availability_zones);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_multiplex_settings(parsed_body.multiplex_settings);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_program_count(parsed_body.program_count);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn describe_multiplex_program_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_multiplex_program_output::Builder,
) -> Result<crate::output::describe_multiplex_program_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeMultiplexProgramOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_channel_id(parsed_body.channel_id);
    builder = builder.set_multiplex_program_settings(parsed_body.multiplex_program_settings);
    builder = builder.set_packet_identifiers_map(parsed_body.packet_identifiers_map);
    builder = builder.set_pipeline_details(parsed_body.pipeline_details);
    builder = builder.set_program_name(parsed_body.program_name);
    Ok(builder)
}

pub fn describe_offering_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_offering_output::Builder,
) -> Result<crate::output::describe_offering_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeOfferingOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_currency_code(parsed_body.currency_code);
    builder = builder.set_duration(parsed_body.duration);
    builder = builder.set_duration_units(parsed_body.duration_units);
    builder = builder.set_fixed_price(parsed_body.fixed_price);
    builder = builder.set_offering_description(parsed_body.offering_description);
    builder = builder.set_offering_id(parsed_body.offering_id);
    builder = builder.set_offering_type(parsed_body.offering_type);
    builder = builder.set_region(parsed_body.region);
    builder = builder.set_resource_specification(parsed_body.resource_specification);
    builder = builder.set_usage_price(parsed_body.usage_price);
    Ok(builder)
}

pub fn describe_reservation_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_reservation_output::Builder,
) -> Result<crate::output::describe_reservation_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeReservationOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_count(parsed_body.count);
    builder = builder.set_currency_code(parsed_body.currency_code);
    builder = builder.set_duration(parsed_body.duration);
    builder = builder.set_duration_units(parsed_body.duration_units);
    builder = builder.set_end(parsed_body.end);
    builder = builder.set_fixed_price(parsed_body.fixed_price);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_offering_description(parsed_body.offering_description);
    builder = builder.set_offering_id(parsed_body.offering_id);
    builder = builder.set_offering_type(parsed_body.offering_type);
    builder = builder.set_region(parsed_body.region);
    builder = builder.set_reservation_id(parsed_body.reservation_id);
    builder = builder.set_resource_specification(parsed_body.resource_specification);
    builder = builder.set_start(parsed_body.start);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_usage_price(parsed_body.usage_price);
    Ok(builder)
}

pub fn describe_schedule_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_schedule_output::Builder,
) -> Result<crate::output::describe_schedule_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeScheduleOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_schedule_actions(parsed_body.schedule_actions);
    Ok(builder)
}

pub fn list_channels_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_channels_output::Builder,
) -> Result<crate::output::list_channels_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListChannelsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_channels(parsed_body.channels);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_input_devices_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_input_devices_output::Builder,
) -> Result<crate::output::list_input_devices_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListInputDevicesOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_input_devices(parsed_body.input_devices);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_input_device_transfers_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_input_device_transfers_output::Builder,
) -> Result<crate::output::list_input_device_transfers_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListInputDeviceTransfersOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_input_device_transfers(parsed_body.input_device_transfers);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_inputs_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_inputs_output::Builder,
) -> Result<crate::output::list_inputs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListInputsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_inputs(parsed_body.inputs);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_input_security_groups_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_input_security_groups_output::Builder,
) -> Result<crate::output::list_input_security_groups_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListInputSecurityGroupsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_input_security_groups(parsed_body.input_security_groups);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_multiplexes_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_multiplexes_output::Builder,
) -> Result<crate::output::list_multiplexes_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListMultiplexesOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_multiplexes(parsed_body.multiplexes);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_multiplex_programs_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_multiplex_programs_output::Builder,
) -> Result<crate::output::list_multiplex_programs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListMultiplexProgramsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_multiplex_programs(parsed_body.multiplex_programs);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_offerings_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_offerings_output::Builder,
) -> Result<crate::output::list_offerings_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListOfferingsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_offerings(parsed_body.offerings);
    Ok(builder)
}

pub fn list_reservations_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_reservations_output::Builder,
) -> Result<crate::output::list_reservations_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListReservationsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_reservations(parsed_body.reservations);
    Ok(builder)
}

pub fn list_tags_for_resource_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_tags_for_resource_output::Builder,
) -> Result<crate::output::list_tags_for_resource_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTagsForResourceOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn purchase_offering_deser_operation(
    inp: &[u8],
    mut builder: crate::output::purchase_offering_output::Builder,
) -> Result<crate::output::purchase_offering_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PurchaseOfferingOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_reservation(parsed_body.reservation);
    Ok(builder)
}

pub fn start_channel_deser_operation(
    inp: &[u8],
    mut builder: crate::output::start_channel_output::Builder,
) -> Result<crate::output::start_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StartChannelOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_cdi_input_specification(parsed_body.cdi_input_specification);
    builder = builder.set_channel_class(parsed_body.channel_class);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_egress_endpoints(parsed_body.egress_endpoints);
    builder = builder.set_encoder_settings(parsed_body.encoder_settings);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_input_attachments(parsed_body.input_attachments);
    builder = builder.set_input_specification(parsed_body.input_specification);
    builder = builder.set_log_level(parsed_body.log_level);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipeline_details(parsed_body.pipeline_details);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_vpc(parsed_body.vpc);
    Ok(builder)
}

pub fn start_multiplex_deser_operation(
    inp: &[u8],
    mut builder: crate::output::start_multiplex_output::Builder,
) -> Result<crate::output::start_multiplex_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StartMultiplexOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_availability_zones(parsed_body.availability_zones);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_multiplex_settings(parsed_body.multiplex_settings);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_program_count(parsed_body.program_count);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn stop_channel_deser_operation(
    inp: &[u8],
    mut builder: crate::output::stop_channel_output::Builder,
) -> Result<crate::output::stop_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StopChannelOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_cdi_input_specification(parsed_body.cdi_input_specification);
    builder = builder.set_channel_class(parsed_body.channel_class);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_egress_endpoints(parsed_body.egress_endpoints);
    builder = builder.set_encoder_settings(parsed_body.encoder_settings);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_input_attachments(parsed_body.input_attachments);
    builder = builder.set_input_specification(parsed_body.input_specification);
    builder = builder.set_log_level(parsed_body.log_level);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipeline_details(parsed_body.pipeline_details);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_role_arn(parsed_body.role_arn);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_vpc(parsed_body.vpc);
    Ok(builder)
}

pub fn stop_multiplex_deser_operation(
    inp: &[u8],
    mut builder: crate::output::stop_multiplex_output::Builder,
) -> Result<crate::output::stop_multiplex_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StopMultiplexOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_availability_zones(parsed_body.availability_zones);
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_multiplex_settings(parsed_body.multiplex_settings);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_pipelines_running_count(parsed_body.pipelines_running_count);
    builder = builder.set_program_count(parsed_body.program_count);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn update_channel_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_channel_output::Builder,
) -> Result<crate::output::update_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateChannelOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_channel(parsed_body.channel);
    Ok(builder)
}

pub fn update_channel_class_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_channel_class_output::Builder,
) -> Result<crate::output::update_channel_class_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateChannelClassOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_channel(parsed_body.channel);
    Ok(builder)
}

pub fn update_input_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_input_output::Builder,
) -> Result<crate::output::update_input_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateInputOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_input(parsed_body.input);
    Ok(builder)
}

pub fn update_input_device_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_input_device_output::Builder,
) -> Result<crate::output::update_input_device_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateInputDeviceOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_connection_state(parsed_body.connection_state);
    builder = builder.set_device_settings_sync_state(parsed_body.device_settings_sync_state);
    builder = builder.set_device_update_status(parsed_body.device_update_status);
    builder = builder.set_hd_device_settings(parsed_body.hd_device_settings);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_mac_address(parsed_body.mac_address);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_network_settings(parsed_body.network_settings);
    builder = builder.set_serial_number(parsed_body.serial_number);
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_uhd_device_settings(parsed_body.uhd_device_settings);
    Ok(builder)
}

pub fn update_input_security_group_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_input_security_group_output::Builder,
) -> Result<crate::output::update_input_security_group_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateInputSecurityGroupOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_security_group(parsed_body.security_group);
    Ok(builder)
}

pub fn update_multiplex_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_multiplex_output::Builder,
) -> Result<crate::output::update_multiplex_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateMultiplexOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_multiplex(parsed_body.multiplex);
    Ok(builder)
}

pub fn update_multiplex_program_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_multiplex_program_output::Builder,
) -> Result<crate::output::update_multiplex_program_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateMultiplexProgramOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_multiplex_program(parsed_body.multiplex_program);
    Ok(builder)
}

pub fn update_reservation_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_reservation_output::Builder,
) -> Result<crate::output::update_reservation_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateReservationOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_reservation(parsed_body.reservation);
    Ok(builder)
}
