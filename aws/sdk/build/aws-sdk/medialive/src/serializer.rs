// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// A request to delete resources
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDeleteInputBody<'a> {
    /// List of channel IDs
    pub channel_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// List of input IDs
    pub input_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// List of input security group IDs
    pub input_security_group_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// List of multiplex IDs
    pub multiplex_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for BatchDeleteInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDeleteInputBody");
        formatter.field("channel_ids", &self.channel_ids);
        formatter.field("input_ids", &self.input_ids);
        formatter.field("input_security_group_ids", &self.input_security_group_ids);
        formatter.field("multiplex_ids", &self.multiplex_ids);
        formatter.finish()
    }
}

/// A request to start resources
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchStartInputBody<'a> {
    /// List of channel IDs
    pub channel_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// List of multiplex IDs
    pub multiplex_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for BatchStartInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchStartInputBody");
        formatter.field("channel_ids", &self.channel_ids);
        formatter.field("multiplex_ids", &self.multiplex_ids);
        formatter.finish()
    }
}

/// A request to stop resources
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchStopInputBody<'a> {
    /// List of channel IDs
    pub channel_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// List of multiplex IDs
    pub multiplex_ids: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for BatchStopInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchStopInputBody");
        formatter.field("channel_ids", &self.channel_ids);
        formatter.field("multiplex_ids", &self.multiplex_ids);
        formatter.finish()
    }
}

/// List of actions to create and list of actions to delete.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchUpdateScheduleInputBody<'a> {
    /// Schedule actions to create in the schedule.
    pub creates: &'a std::option::Option<crate::model::BatchScheduleActionCreateRequest>,
    /// Schedule actions to delete from the schedule.
    pub deletes: &'a std::option::Option<crate::model::BatchScheduleActionDeleteRequest>,
}
impl<'a> std::fmt::Debug for BatchUpdateScheduleInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchUpdateScheduleInputBody");
        formatter.field("creates", &self.creates);
        formatter.field("deletes", &self.deletes);
        formatter.finish()
    }
}

/// A request to create a channel
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelInputBody<'a> {
    /// Specification of CDI inputs for this channel
    pub cdi_input_specification: &'a std::option::Option<crate::model::CdiInputSpecification>,
    /// The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
    pub channel_class: &'a std::option::Option<crate::model::ChannelClass>,
    /// Placeholder documentation for __listOfOutputDestination
    pub destinations: &'a std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
    /// Encoder Settings
    pub encoder_settings: &'a std::option::Option<crate::model::EncoderSettings>,
    /// List of input attachments for channel.
    pub input_attachments: &'a std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
    /// Specification of network and file inputs for this channel
    pub input_specification: &'a std::option::Option<crate::model::InputSpecification>,
    /// The log level to write to CloudWatch Logs.
    pub log_level: &'a std::option::Option<crate::model::LogLevel>,
    /// Name of channel.
    pub name: &'a std::option::Option<std::string::String>,
    /// Unique request ID to be specified. This is needed to prevent retries from
    /// creating multiple resources.
    pub request_id: &'a std::option::Option<std::string::String>,
    /// Deprecated field that's only usable by whitelisted customers.
    pub reserved: &'a std::option::Option<std::string::String>,
    /// An optional Amazon Resource Name (ARN) of the role to assume when running the Channel.
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// A collection of key-value pairs.
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// Settings for VPC output
    pub vpc: &'a std::option::Option<crate::model::VpcOutputSettings>,
}
impl<'a> std::fmt::Debug for CreateChannelInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelInputBody");
        formatter.field("cdi_input_specification", &self.cdi_input_specification);
        formatter.field("channel_class", &self.channel_class);
        formatter.field("destinations", &self.destinations);
        formatter.field("encoder_settings", &self.encoder_settings);
        formatter.field("input_attachments", &self.input_attachments);
        formatter.field("input_specification", &self.input_specification);
        formatter.field("log_level", &self.log_level);
        formatter.field("name", &self.name);
        formatter.field("request_id", &self.request_id);
        formatter.field("reserved", &self.reserved);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.field("vpc", &self.vpc);
        formatter.finish()
    }
}

/// The name of the input
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInputInputBody<'a> {
    /// Destination settings for PUSH type inputs.
    pub destinations: &'a std::option::Option<std::vec::Vec<crate::model::InputDestinationRequest>>,
    /// Settings for the devices.
    pub input_devices: &'a std::option::Option<std::vec::Vec<crate::model::InputDeviceSettings>>,
    /// A list of security groups referenced by IDs to attach to the input.
    pub input_security_groups: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the MediaConnect Flows that you want to use in this input. You can specify as few as one
    /// Flow and presently, as many as two. The only requirement is when you have more than one is that each Flow is in a
    /// separate Availability Zone as this ensures your EML input is redundant to AZ issues.
    pub media_connect_flows:
        &'a std::option::Option<std::vec::Vec<crate::model::MediaConnectFlowRequest>>,
    /// Name of the input.
    pub name: &'a std::option::Option<std::string::String>,
    /// Unique identifier of the request to ensure the request is handled
    /// exactly once in case of retries.
    pub request_id: &'a std::option::Option<std::string::String>,
    /// The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// The source URLs for a PULL-type input. Every PULL type input needs
    /// exactly two source URLs for redundancy.
    /// Only specify sources for PULL type Inputs. Leave Destinations empty.
    pub sources: &'a std::option::Option<std::vec::Vec<crate::model::InputSourceRequest>>,
    /// A collection of key-value pairs.
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// Placeholder documentation for InputType
    pub r#type: &'a std::option::Option<crate::model::InputType>,
    /// Settings for a private VPC Input.
    /// When this property is specified, the input destination addresses will be created in a VPC rather than with public Internet addresses.
    /// This property requires setting the roleArn property on Input creation.
    /// Not compatible with the inputSecurityGroups property.
    pub vpc: &'a std::option::Option<crate::model::InputVpcRequest>,
}
impl<'a> std::fmt::Debug for CreateInputInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInputInputBody");
        formatter.field("destinations", &self.destinations);
        formatter.field("input_devices", &self.input_devices);
        formatter.field("input_security_groups", &self.input_security_groups);
        formatter.field("media_connect_flows", &self.media_connect_flows);
        formatter.field("name", &self.name);
        formatter.field("request_id", &self.request_id);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("sources", &self.sources);
        formatter.field("tags", &self.tags);
        formatter.field("r#type", &self.r#type);
        formatter.field("vpc", &self.vpc);
        formatter.finish()
    }
}

/// The IPv4 CIDRs to whitelist for this Input Security Group
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInputSecurityGroupInputBody<'a> {
    /// A collection of key-value pairs.
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// List of IPv4 CIDR addresses to whitelist
    pub whitelist_rules:
        &'a std::option::Option<std::vec::Vec<crate::model::InputWhitelistRuleCidr>>,
}
impl<'a> std::fmt::Debug for CreateInputSecurityGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInputSecurityGroupInputBody");
        formatter.field("tags", &self.tags);
        formatter.field("whitelist_rules", &self.whitelist_rules);
        formatter.finish()
    }
}

/// A request to create a multiplex.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMultiplexInputBody<'a> {
    /// A list of availability zones for the multiplex. You must specify exactly two.
    pub availability_zones: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// Configuration for a multiplex event.
    pub multiplex_settings: &'a std::option::Option<crate::model::MultiplexSettings>,
    /// Name of multiplex.
    pub name: &'a std::option::Option<std::string::String>,
    /// Unique request ID. This prevents retries from creating multiple
    /// resources.
    pub request_id: &'a std::option::Option<std::string::String>,
    /// A collection of key-value pairs.
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for CreateMultiplexInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMultiplexInputBody");
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("multiplex_settings", &self.multiplex_settings);
        formatter.field("name", &self.name);
        formatter.field("request_id", &self.request_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// A request to create a program in a multiplex.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMultiplexProgramInputBody<'a> {
    /// The settings for this multiplex program.
    pub multiplex_program_settings: &'a std::option::Option<crate::model::MultiplexProgramSettings>,
    /// Name of multiplex program.
    pub program_name: &'a std::option::Option<std::string::String>,
    /// Unique request ID. This prevents retries from creating multiple
    /// resources.
    pub request_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateMultiplexProgramInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMultiplexProgramInputBody");
        formatter.field(
            "multiplex_program_settings",
            &self.multiplex_program_settings,
        );
        formatter.field("program_name", &self.program_name);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}

/// A request to create a partner input
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePartnerInputInputBody<'a> {
    /// Unique identifier of the request to ensure the request is handled
    /// exactly once in case of retries.
    pub request_id: &'a std::option::Option<std::string::String>,
    /// A collection of key-value pairs.
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for CreatePartnerInputInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePartnerInputInputBody");
        formatter.field("request_id", &self.request_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Placeholder documentation for CreateTagsRequest
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTagsInputBody<'a> {
    /// Placeholder documentation for Tags
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for CreateTagsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTagsInputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Placeholder documentation for PurchaseOfferingRequest
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PurchaseOfferingInputBody<'a> {
    /// Number of resources
    pub count: &'a i32,
    /// Name for the new reservation
    pub name: &'a std::option::Option<std::string::String>,
    /// Unique request ID to be specified. This is needed to prevent retries from creating multiple resources.
    pub request_id: &'a std::option::Option<std::string::String>,
    /// Requested reservation start time (UTC) in ISO-8601 format. The specified time must be between the first day of the current month and one year from now. If no value is given, the default is now.
    pub start: &'a std::option::Option<std::string::String>,
    /// A collection of key-value pairs
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for PurchaseOfferingInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PurchaseOfferingInputBody");
        formatter.field("count", &self.count);
        formatter.field("name", &self.name);
        formatter.field("request_id", &self.request_id);
        formatter.field("start", &self.start);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// A request to transfer an input device.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferInputDeviceInputBody<'a> {
    /// The AWS account ID (12 digits) for the recipient of the device transfer.
    pub target_customer_id: &'a std::option::Option<std::string::String>,
    /// The target AWS region to transfer the device.
    pub target_region: &'a std::option::Option<std::string::String>,
    /// An optional message for the recipient. Maximum 280 characters.
    pub transfer_message: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for TransferInputDeviceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransferInputDeviceInputBody");
        formatter.field("target_customer_id", &self.target_customer_id);
        formatter.field("target_region", &self.target_region);
        formatter.field("transfer_message", &self.transfer_message);
        formatter.finish()
    }
}

/// A request to update a channel.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelInputBody<'a> {
    /// Specification of CDI inputs for this channel
    pub cdi_input_specification: &'a std::option::Option<crate::model::CdiInputSpecification>,
    /// A list of output destinations for this channel.
    pub destinations: &'a std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
    /// The encoder settings for this channel.
    pub encoder_settings: &'a std::option::Option<crate::model::EncoderSettings>,
    /// Placeholder documentation for __listOfInputAttachment
    pub input_attachments: &'a std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
    /// Specification of network and file inputs for this channel
    pub input_specification: &'a std::option::Option<crate::model::InputSpecification>,
    /// The log level to write to CloudWatch Logs.
    pub log_level: &'a std::option::Option<crate::model::LogLevel>,
    /// The name of the channel.
    pub name: &'a std::option::Option<std::string::String>,
    /// An optional Amazon Resource Name (ARN) of the role to assume when running the Channel. If you do not specify this on an update call but the role was previously set that role will be removed.
    pub role_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateChannelInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelInputBody");
        formatter.field("cdi_input_specification", &self.cdi_input_specification);
        formatter.field("destinations", &self.destinations);
        formatter.field("encoder_settings", &self.encoder_settings);
        formatter.field("input_attachments", &self.input_attachments);
        formatter.field("input_specification", &self.input_specification);
        formatter.field("log_level", &self.log_level);
        formatter.field("name", &self.name);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

/// Channel class that the channel should be updated to.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelClassInputBody<'a> {
    /// The channel class that you wish to update this channel to use.
    pub channel_class: &'a std::option::Option<crate::model::ChannelClass>,
    /// A list of output destinations for this channel.
    pub destinations: &'a std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
}
impl<'a> std::fmt::Debug for UpdateChannelClassInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelClassInputBody");
        formatter.field("channel_class", &self.channel_class);
        formatter.field("destinations", &self.destinations);
        formatter.finish()
    }
}

/// A request to update an input.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInputInputBody<'a> {
    /// Destination settings for PUSH type inputs.
    pub destinations: &'a std::option::Option<std::vec::Vec<crate::model::InputDestinationRequest>>,
    /// Settings for the devices.
    pub input_devices: &'a std::option::Option<std::vec::Vec<crate::model::InputDeviceRequest>>,
    /// A list of security groups referenced by IDs to attach to the input.
    pub input_security_groups: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the MediaConnect Flow ARNs that you want to use as the source of the input. You can specify as few as one
    /// Flow and presently, as many as two. The only requirement is when you have more than one is that each Flow is in a
    /// separate Availability Zone as this ensures your EML input is redundant to AZ issues.
    pub media_connect_flows:
        &'a std::option::Option<std::vec::Vec<crate::model::MediaConnectFlowRequest>>,
    /// Name of the input.
    pub name: &'a std::option::Option<std::string::String>,
    /// The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// The source URLs for a PULL-type input. Every PULL type input needs
    /// exactly two source URLs for redundancy.
    /// Only specify sources for PULL type Inputs. Leave Destinations empty.
    pub sources: &'a std::option::Option<std::vec::Vec<crate::model::InputSourceRequest>>,
}
impl<'a> std::fmt::Debug for UpdateInputInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInputInputBody");
        formatter.field("destinations", &self.destinations);
        formatter.field("input_devices", &self.input_devices);
        formatter.field("input_security_groups", &self.input_security_groups);
        formatter.field("media_connect_flows", &self.media_connect_flows);
        formatter.field("name", &self.name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("sources", &self.sources);
        formatter.finish()
    }
}

/// A request to update an input device.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInputDeviceInputBody<'a> {
    /// The settings that you want to apply to the HD input device.
    pub hd_device_settings: &'a std::option::Option<crate::model::InputDeviceConfigurableSettings>,
    /// The name that you assigned to this input device (not the unique ID).
    pub name: &'a std::option::Option<std::string::String>,
    /// The settings that you want to apply to the UHD input device.
    pub uhd_device_settings: &'a std::option::Option<crate::model::InputDeviceConfigurableSettings>,
}
impl<'a> std::fmt::Debug for UpdateInputDeviceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInputDeviceInputBody");
        formatter.field("hd_device_settings", &self.hd_device_settings);
        formatter.field("name", &self.name);
        formatter.field("uhd_device_settings", &self.uhd_device_settings);
        formatter.finish()
    }
}

/// The request to update some combination of the Input Security Group name and the IPv4 CIDRs the Input Security Group should allow.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInputSecurityGroupInputBody<'a> {
    /// A collection of key-value pairs.
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// List of IPv4 CIDR addresses to whitelist
    pub whitelist_rules:
        &'a std::option::Option<std::vec::Vec<crate::model::InputWhitelistRuleCidr>>,
}
impl<'a> std::fmt::Debug for UpdateInputSecurityGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInputSecurityGroupInputBody");
        formatter.field("tags", &self.tags);
        formatter.field("whitelist_rules", &self.whitelist_rules);
        formatter.finish()
    }
}

/// A request to update a multiplex.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMultiplexInputBody<'a> {
    /// The new settings for a multiplex.
    pub multiplex_settings: &'a std::option::Option<crate::model::MultiplexSettings>,
    /// Name of the multiplex.
    pub name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateMultiplexInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMultiplexInputBody");
        formatter.field("multiplex_settings", &self.multiplex_settings);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

/// A request to update a program in a multiplex.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMultiplexProgramInputBody<'a> {
    /// The new settings for a multiplex program.
    pub multiplex_program_settings: &'a std::option::Option<crate::model::MultiplexProgramSettings>,
}
impl<'a> std::fmt::Debug for UpdateMultiplexProgramInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMultiplexProgramInputBody");
        formatter.field(
            "multiplex_program_settings",
            &self.multiplex_program_settings,
        );
        formatter.finish()
    }
}

/// Request to update a reservation
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateReservationInputBody<'a> {
    /// Name of the reservation
    pub name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateReservationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateReservationInputBody");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

/// Placeholder documentation for BatchDeleteResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDeleteOutputBody {
    /// List of failed operations
    #[serde(rename = "failed")]
    #[serde(default)]
    pub failed: std::option::Option<std::vec::Vec<crate::model::BatchFailedResultModel>>,
    /// List of successful operations
    #[serde(rename = "successful")]
    #[serde(default)]
    pub successful: std::option::Option<std::vec::Vec<crate::model::BatchSuccessfulResultModel>>,
}
impl std::fmt::Debug for BatchDeleteOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDeleteOutputBody");
        formatter.field("failed", &self.failed);
        formatter.field("successful", &self.successful);
        formatter.finish()
    }
}

/// Placeholder documentation for BatchStartResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchStartOutputBody {
    /// List of failed operations
    #[serde(rename = "failed")]
    #[serde(default)]
    pub failed: std::option::Option<std::vec::Vec<crate::model::BatchFailedResultModel>>,
    /// List of successful operations
    #[serde(rename = "successful")]
    #[serde(default)]
    pub successful: std::option::Option<std::vec::Vec<crate::model::BatchSuccessfulResultModel>>,
}
impl std::fmt::Debug for BatchStartOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchStartOutputBody");
        formatter.field("failed", &self.failed);
        formatter.field("successful", &self.successful);
        formatter.finish()
    }
}

/// Placeholder documentation for BatchStopResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchStopOutputBody {
    /// List of failed operations
    #[serde(rename = "failed")]
    #[serde(default)]
    pub failed: std::option::Option<std::vec::Vec<crate::model::BatchFailedResultModel>>,
    /// List of successful operations
    #[serde(rename = "successful")]
    #[serde(default)]
    pub successful: std::option::Option<std::vec::Vec<crate::model::BatchSuccessfulResultModel>>,
}
impl std::fmt::Debug for BatchStopOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchStopOutputBody");
        formatter.field("failed", &self.failed);
        formatter.field("successful", &self.successful);
        formatter.finish()
    }
}

/// Placeholder documentation for BatchUpdateScheduleResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchUpdateScheduleOutputBody {
    /// Schedule actions created in the schedule.
    #[serde(rename = "creates")]
    #[serde(default)]
    pub creates: std::option::Option<crate::model::BatchScheduleActionCreateResult>,
    /// Schedule actions deleted from the schedule.
    #[serde(rename = "deletes")]
    #[serde(default)]
    pub deletes: std::option::Option<crate::model::BatchScheduleActionDeleteResult>,
}
impl std::fmt::Debug for BatchUpdateScheduleOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchUpdateScheduleOutputBody");
        formatter.field("creates", &self.creates);
        formatter.field("deletes", &self.deletes);
        formatter.finish()
    }
}

/// Placeholder documentation for CreateChannelResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelOutputBody {
    /// Placeholder documentation for Channel
    #[serde(rename = "channel")]
    #[serde(default)]
    pub channel: std::option::Option<crate::model::Channel>,
}
impl std::fmt::Debug for CreateChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelOutputBody");
        formatter.field("channel", &self.channel);
        formatter.finish()
    }
}

/// Placeholder documentation for CreateInputResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInputOutputBody {
    /// Placeholder documentation for Input
    #[serde(rename = "input")]
    #[serde(default)]
    pub input: std::option::Option<crate::model::Input>,
}
impl std::fmt::Debug for CreateInputOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInputOutputBody");
        formatter.field("input", &self.input);
        formatter.finish()
    }
}

/// Placeholder documentation for CreateInputSecurityGroupResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInputSecurityGroupOutputBody {
    /// An Input Security Group
    #[serde(rename = "securityGroup")]
    #[serde(default)]
    pub security_group: std::option::Option<crate::model::InputSecurityGroup>,
}
impl std::fmt::Debug for CreateInputSecurityGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInputSecurityGroupOutputBody");
        formatter.field("security_group", &self.security_group);
        formatter.finish()
    }
}

/// Placeholder documentation for CreateMultiplexResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMultiplexOutputBody {
    /// The newly created multiplex.
    #[serde(rename = "multiplex")]
    #[serde(default)]
    pub multiplex: std::option::Option<crate::model::Multiplex>,
}
impl std::fmt::Debug for CreateMultiplexOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMultiplexOutputBody");
        formatter.field("multiplex", &self.multiplex);
        formatter.finish()
    }
}

/// Placeholder documentation for CreateMultiplexProgramResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMultiplexProgramOutputBody {
    /// The newly created multiplex program.
    #[serde(rename = "multiplexProgram")]
    #[serde(default)]
    pub multiplex_program: std::option::Option<crate::model::MultiplexProgram>,
}
impl std::fmt::Debug for CreateMultiplexProgramOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMultiplexProgramOutputBody");
        formatter.field("multiplex_program", &self.multiplex_program);
        formatter.finish()
    }
}

/// Placeholder documentation for CreatePartnerInputResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePartnerInputOutputBody {
    /// Placeholder documentation for Input
    #[serde(rename = "input")]
    #[serde(default)]
    pub input: std::option::Option<crate::model::Input>,
}
impl std::fmt::Debug for CreatePartnerInputOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePartnerInputOutputBody");
        formatter.field("input", &self.input);
        formatter.finish()
    }
}

/// Placeholder documentation for DeleteChannelResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelOutputBody {
    /// The unique arn of the channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// Specification of CDI inputs for this channel
    #[serde(rename = "cdiInputSpecification")]
    #[serde(default)]
    pub cdi_input_specification: std::option::Option<crate::model::CdiInputSpecification>,
    /// The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
    #[serde(rename = "channelClass")]
    #[serde(default)]
    pub channel_class: std::option::Option<crate::model::ChannelClass>,
    /// A list of destinations of the channel. For UDP outputs, there is one
    /// destination per output. For other types (HLS, for example), there is
    /// one destination per packager.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
    /// The endpoints where outgoing connections initiate from
    #[serde(rename = "egressEndpoints")]
    #[serde(default)]
    pub egress_endpoints: std::option::Option<std::vec::Vec<crate::model::ChannelEgressEndpoint>>,
    /// Encoder Settings
    #[serde(rename = "encoderSettings")]
    #[serde(default)]
    pub encoder_settings: std::option::Option<crate::model::EncoderSettings>,
    /// The unique id of the channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// List of input attachments for channel.
    #[serde(rename = "inputAttachments")]
    #[serde(default)]
    pub input_attachments: std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
    /// Specification of network and file inputs for this channel
    #[serde(rename = "inputSpecification")]
    #[serde(default)]
    pub input_specification: std::option::Option<crate::model::InputSpecification>,
    /// The log level being written to CloudWatch Logs.
    #[serde(rename = "logLevel")]
    #[serde(default)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
    /// The name of the channel. (user-mutable)
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// Runtime details for the pipelines of a running channel.
    #[serde(rename = "pipelineDetails")]
    #[serde(default)]
    pub pipeline_details: std::option::Option<std::vec::Vec<crate::model::PipelineDetail>>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The Amazon Resource Name (ARN) of the role assumed when running the Channel.
    #[serde(rename = "roleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// Placeholder documentation for ChannelState
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::ChannelState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Settings for VPC output
    #[serde(rename = "vpc")]
    #[serde(default)]
    pub vpc: std::option::Option<crate::model::VpcOutputSettingsDescription>,
}
impl std::fmt::Debug for DeleteChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("cdi_input_specification", &self.cdi_input_specification);
        formatter.field("channel_class", &self.channel_class);
        formatter.field("destinations", &self.destinations);
        formatter.field("egress_endpoints", &self.egress_endpoints);
        formatter.field("encoder_settings", &self.encoder_settings);
        formatter.field("id", &self.id);
        formatter.field("input_attachments", &self.input_attachments);
        formatter.field("input_specification", &self.input_specification);
        formatter.field("log_level", &self.log_level);
        formatter.field("name", &self.name);
        formatter.field("pipeline_details", &self.pipeline_details);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("vpc", &self.vpc);
        formatter.finish()
    }
}

/// Placeholder documentation for DeleteMultiplexResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMultiplexOutputBody {
    /// The unique arn of the multiplex.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A list of availability zones for the multiplex.
    #[serde(rename = "availabilityZones")]
    #[serde(default)]
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the multiplex output destinations.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::MultiplexOutputDestination>>,
    /// The unique id of the multiplex.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configuration for a multiplex event.
    #[serde(rename = "multiplexSettings")]
    #[serde(default)]
    pub multiplex_settings: std::option::Option<crate::model::MultiplexSettings>,
    /// The name of the multiplex.
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The number of programs in the multiplex.
    #[serde(rename = "programCount")]
    #[serde(default)]
    pub program_count: i32,
    /// The current state of the multiplex.
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::MultiplexState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DeleteMultiplexOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMultiplexOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("destinations", &self.destinations);
        formatter.field("id", &self.id);
        formatter.field("multiplex_settings", &self.multiplex_settings);
        formatter.field("name", &self.name);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("program_count", &self.program_count);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Placeholder documentation for DeleteMultiplexProgramResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMultiplexProgramOutputBody {
    /// The MediaLive channel associated with the program.
    #[serde(rename = "channelId")]
    #[serde(default)]
    pub channel_id: std::option::Option<std::string::String>,
    /// The settings for this multiplex program.
    #[serde(rename = "multiplexProgramSettings")]
    #[serde(default)]
    pub multiplex_program_settings: std::option::Option<crate::model::MultiplexProgramSettings>,
    /// The packet identifier map for this multiplex program.
    #[serde(rename = "packetIdentifiersMap")]
    #[serde(default)]
    pub packet_identifiers_map:
        std::option::Option<crate::model::MultiplexProgramPacketIdentifiersMap>,
    /// Contains information about the current sources for the specified program in the specified multiplex. Keep in mind that each multiplex pipeline connects to both pipelines in a given source channel (the channel identified by the program). But only one of those channel pipelines is ever active at one time.
    #[serde(rename = "pipelineDetails")]
    #[serde(default)]
    pub pipeline_details:
        std::option::Option<std::vec::Vec<crate::model::MultiplexProgramPipelineDetail>>,
    /// The name of the multiplex program.
    #[serde(rename = "programName")]
    #[serde(default)]
    pub program_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMultiplexProgramOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMultiplexProgramOutputBody");
        formatter.field("channel_id", &self.channel_id);
        formatter.field(
            "multiplex_program_settings",
            &self.multiplex_program_settings,
        );
        formatter.field("packet_identifiers_map", &self.packet_identifiers_map);
        formatter.field("pipeline_details", &self.pipeline_details);
        formatter.field("program_name", &self.program_name);
        formatter.finish()
    }
}

/// Placeholder documentation for DeleteReservationResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteReservationOutputBody {
    /// Unique reservation ARN, e.g. 'arn:aws:medialive:us-west-2:123456789012:reservation:1234567'
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// Number of reserved resources
    #[serde(rename = "count")]
    #[serde(default)]
    pub count: i32,
    /// Currency code for usagePrice and fixedPrice in ISO-4217 format, e.g. 'USD'
    #[serde(rename = "currencyCode")]
    #[serde(default)]
    pub currency_code: std::option::Option<std::string::String>,
    /// Lease duration, e.g. '12'
    #[serde(rename = "duration")]
    #[serde(default)]
    pub duration: i32,
    /// Units for duration, e.g. 'MONTHS'
    #[serde(rename = "durationUnits")]
    #[serde(default)]
    pub duration_units: std::option::Option<crate::model::OfferingDurationUnits>,
    /// Reservation UTC end date and time in ISO-8601 format, e.g. '2019-03-01T00:00:00'
    #[serde(rename = "end")]
    #[serde(default)]
    pub end: std::option::Option<std::string::String>,
    /// One-time charge for each reserved resource, e.g. '0.0' for a NO_UPFRONT offering
    #[serde(rename = "fixedPrice")]
    #[serde(default)]
    pub fixed_price: f64,
    /// User specified reservation name
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// Offering description, e.g. 'HD AVC output at 10-20 Mbps, 30 fps, and standard VQ in US West (Oregon)'
    #[serde(rename = "offeringDescription")]
    #[serde(default)]
    pub offering_description: std::option::Option<std::string::String>,
    /// Unique offering ID, e.g. '87654321'
    #[serde(rename = "offeringId")]
    #[serde(default)]
    pub offering_id: std::option::Option<std::string::String>,
    /// Offering type, e.g. 'NO_UPFRONT'
    #[serde(rename = "offeringType")]
    #[serde(default)]
    pub offering_type: std::option::Option<crate::model::OfferingType>,
    /// AWS region, e.g. 'us-west-2'
    #[serde(rename = "region")]
    #[serde(default)]
    pub region: std::option::Option<std::string::String>,
    /// Unique reservation ID, e.g. '1234567'
    #[serde(rename = "reservationId")]
    #[serde(default)]
    pub reservation_id: std::option::Option<std::string::String>,
    /// Resource configuration details
    #[serde(rename = "resourceSpecification")]
    #[serde(default)]
    pub resource_specification: std::option::Option<crate::model::ReservationResourceSpecification>,
    /// Reservation UTC start date and time in ISO-8601 format, e.g. '2018-03-01T00:00:00'
    #[serde(rename = "start")]
    #[serde(default)]
    pub start: std::option::Option<std::string::String>,
    /// Current state of reservation, e.g. 'ACTIVE'
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::ReservationState>,
    /// A collection of key-value pairs
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Recurring usage charge for each reserved resource, e.g. '157.0'
    #[serde(rename = "usagePrice")]
    #[serde(default)]
    pub usage_price: f64,
}
impl std::fmt::Debug for DeleteReservationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteReservationOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("count", &self.count);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("duration", &self.duration);
        formatter.field("duration_units", &self.duration_units);
        formatter.field("end", &self.end);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("name", &self.name);
        formatter.field("offering_description", &self.offering_description);
        formatter.field("offering_id", &self.offering_id);
        formatter.field("offering_type", &self.offering_type);
        formatter.field("region", &self.region);
        formatter.field("reservation_id", &self.reservation_id);
        formatter.field("resource_specification", &self.resource_specification);
        formatter.field("start", &self.start);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("usage_price", &self.usage_price);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeChannelResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelOutputBody {
    /// The unique arn of the channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// Specification of CDI inputs for this channel
    #[serde(rename = "cdiInputSpecification")]
    #[serde(default)]
    pub cdi_input_specification: std::option::Option<crate::model::CdiInputSpecification>,
    /// The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
    #[serde(rename = "channelClass")]
    #[serde(default)]
    pub channel_class: std::option::Option<crate::model::ChannelClass>,
    /// A list of destinations of the channel. For UDP outputs, there is one
    /// destination per output. For other types (HLS, for example), there is
    /// one destination per packager.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
    /// The endpoints where outgoing connections initiate from
    #[serde(rename = "egressEndpoints")]
    #[serde(default)]
    pub egress_endpoints: std::option::Option<std::vec::Vec<crate::model::ChannelEgressEndpoint>>,
    /// Encoder Settings
    #[serde(rename = "encoderSettings")]
    #[serde(default)]
    pub encoder_settings: std::option::Option<crate::model::EncoderSettings>,
    /// The unique id of the channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// List of input attachments for channel.
    #[serde(rename = "inputAttachments")]
    #[serde(default)]
    pub input_attachments: std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
    /// Specification of network and file inputs for this channel
    #[serde(rename = "inputSpecification")]
    #[serde(default)]
    pub input_specification: std::option::Option<crate::model::InputSpecification>,
    /// The log level being written to CloudWatch Logs.
    #[serde(rename = "logLevel")]
    #[serde(default)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
    /// The name of the channel. (user-mutable)
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// Runtime details for the pipelines of a running channel.
    #[serde(rename = "pipelineDetails")]
    #[serde(default)]
    pub pipeline_details: std::option::Option<std::vec::Vec<crate::model::PipelineDetail>>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The Amazon Resource Name (ARN) of the role assumed when running the Channel.
    #[serde(rename = "roleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// Placeholder documentation for ChannelState
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::ChannelState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Settings for VPC output
    #[serde(rename = "vpc")]
    #[serde(default)]
    pub vpc: std::option::Option<crate::model::VpcOutputSettingsDescription>,
}
impl std::fmt::Debug for DescribeChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("cdi_input_specification", &self.cdi_input_specification);
        formatter.field("channel_class", &self.channel_class);
        formatter.field("destinations", &self.destinations);
        formatter.field("egress_endpoints", &self.egress_endpoints);
        formatter.field("encoder_settings", &self.encoder_settings);
        formatter.field("id", &self.id);
        formatter.field("input_attachments", &self.input_attachments);
        formatter.field("input_specification", &self.input_specification);
        formatter.field("log_level", &self.log_level);
        formatter.field("name", &self.name);
        formatter.field("pipeline_details", &self.pipeline_details);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("vpc", &self.vpc);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeInputResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInputOutputBody {
    /// The Unique ARN of the input (generated, immutable).
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A list of channel IDs that that input is attached to (currently an input can only be attached to one channel).
    #[serde(rename = "attachedChannels")]
    #[serde(default)]
    pub attached_channels: std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the destinations of the input (PUSH-type).
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::InputDestination>>,
    /// The generated ID of the input (unique for user account, immutable).
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// STANDARD - MediaLive expects two sources to be connected to this input. If the channel is also STANDARD, both sources will be ingested. If the channel is SINGLE_PIPELINE, only the first source will be ingested; the second source will always be ignored, even if the first source fails.
    /// SINGLE_PIPELINE - You can connect only one source to this input. If the ChannelClass is also  SINGLE_PIPELINE, this value is valid. If the ChannelClass is STANDARD, this value is not valid because the channel requires two sources in the input.
    #[serde(rename = "inputClass")]
    #[serde(default)]
    pub input_class: std::option::Option<crate::model::InputClass>,
    /// Settings for the input devices.
    #[serde(rename = "inputDevices")]
    #[serde(default)]
    pub input_devices: std::option::Option<std::vec::Vec<crate::model::InputDeviceSettings>>,
    /// A list of IDs for all Inputs which are partners of this one.
    #[serde(rename = "inputPartnerIds")]
    #[serde(default)]
    pub input_partner_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// Certain pull input sources can be dynamic, meaning that they can have their URL's dynamically changes
    /// during input switch actions. Presently, this functionality only works with MP4_FILE inputs.
    #[serde(rename = "inputSourceType")]
    #[serde(default)]
    pub input_source_type: std::option::Option<crate::model::InputSourceType>,
    /// A list of MediaConnect Flows for this input.
    #[serde(rename = "mediaConnectFlows")]
    #[serde(default)]
    pub media_connect_flows: std::option::Option<std::vec::Vec<crate::model::MediaConnectFlow>>,
    /// The user-assigned name (This is a mutable value).
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
    #[serde(rename = "roleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// A list of IDs for all the Input Security Groups attached to the input.
    #[serde(rename = "securityGroups")]
    #[serde(default)]
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the sources of the input (PULL-type).
    #[serde(rename = "sources")]
    #[serde(default)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::InputSource>>,
    /// Placeholder documentation for InputState
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::InputState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Placeholder documentation for InputType
    #[serde(rename = "type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::InputType>,
}
impl std::fmt::Debug for DescribeInputOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInputOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("attached_channels", &self.attached_channels);
        formatter.field("destinations", &self.destinations);
        formatter.field("id", &self.id);
        formatter.field("input_class", &self.input_class);
        formatter.field("input_devices", &self.input_devices);
        formatter.field("input_partner_ids", &self.input_partner_ids);
        formatter.field("input_source_type", &self.input_source_type);
        formatter.field("media_connect_flows", &self.media_connect_flows);
        formatter.field("name", &self.name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("sources", &self.sources);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeInputDeviceResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInputDeviceOutputBody {
    /// The unique ARN of the input device.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// The state of the connection between the input device and AWS.
    #[serde(rename = "connectionState")]
    #[serde(default)]
    pub connection_state: std::option::Option<crate::model::InputDeviceConnectionState>,
    /// The status of the action to synchronize the device configuration. If you change the configuration of the input device (for example, the maximum bitrate), MediaLive sends the new data to the device. The device might not update itself immediately. SYNCED means the device has updated its configuration. SYNCING means that it has not updated its configuration.
    #[serde(rename = "deviceSettingsSyncState")]
    #[serde(default)]
    pub device_settings_sync_state: std::option::Option<crate::model::DeviceSettingsSyncState>,
    /// The status of software on the input device.
    #[serde(rename = "deviceUpdateStatus")]
    #[serde(default)]
    pub device_update_status: std::option::Option<crate::model::DeviceUpdateStatus>,
    /// Settings that describe an input device that is type HD.
    #[serde(rename = "hdDeviceSettings")]
    #[serde(default)]
    pub hd_device_settings: std::option::Option<crate::model::InputDeviceHdSettings>,
    /// The unique ID of the input device.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// The network MAC address of the input device.
    #[serde(rename = "macAddress")]
    #[serde(default)]
    pub mac_address: std::option::Option<std::string::String>,
    /// A name that you specify for the input device.
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// The network settings for the input device.
    #[serde(rename = "networkSettings")]
    #[serde(default)]
    pub network_settings: std::option::Option<crate::model::InputDeviceNetworkSettings>,
    /// The unique serial number of the input device.
    #[serde(rename = "serialNumber")]
    #[serde(default)]
    pub serial_number: std::option::Option<std::string::String>,
    /// The type of the input device.
    #[serde(rename = "type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::InputDeviceType>,
    /// Settings that describe an input device that is type UHD.
    #[serde(rename = "uhdDeviceSettings")]
    #[serde(default)]
    pub uhd_device_settings: std::option::Option<crate::model::InputDeviceUhdSettings>,
}
impl std::fmt::Debug for DescribeInputDeviceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInputDeviceOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("connection_state", &self.connection_state);
        formatter.field(
            "device_settings_sync_state",
            &self.device_settings_sync_state,
        );
        formatter.field("device_update_status", &self.device_update_status);
        formatter.field("hd_device_settings", &self.hd_device_settings);
        formatter.field("id", &self.id);
        formatter.field("mac_address", &self.mac_address);
        formatter.field("name", &self.name);
        formatter.field("network_settings", &self.network_settings);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("r#type", &self.r#type);
        formatter.field("uhd_device_settings", &self.uhd_device_settings);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeInputSecurityGroupResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInputSecurityGroupOutputBody {
    /// Unique ARN of Input Security Group
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// The Id of the Input Security Group
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// The list of inputs currently using this Input Security Group.
    #[serde(rename = "inputs")]
    #[serde(default)]
    pub inputs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// The current state of the Input Security Group.
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::InputSecurityGroupState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Whitelist rules and their sync status
    #[serde(rename = "whitelistRules")]
    #[serde(default)]
    pub whitelist_rules: std::option::Option<std::vec::Vec<crate::model::InputWhitelistRule>>,
}
impl std::fmt::Debug for DescribeInputSecurityGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInputSecurityGroupOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("inputs", &self.inputs);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("whitelist_rules", &self.whitelist_rules);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeMultiplexResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMultiplexOutputBody {
    /// The unique arn of the multiplex.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A list of availability zones for the multiplex.
    #[serde(rename = "availabilityZones")]
    #[serde(default)]
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the multiplex output destinations.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::MultiplexOutputDestination>>,
    /// The unique id of the multiplex.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configuration for a multiplex event.
    #[serde(rename = "multiplexSettings")]
    #[serde(default)]
    pub multiplex_settings: std::option::Option<crate::model::MultiplexSettings>,
    /// The name of the multiplex.
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The number of programs in the multiplex.
    #[serde(rename = "programCount")]
    #[serde(default)]
    pub program_count: i32,
    /// The current state of the multiplex.
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::MultiplexState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DescribeMultiplexOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMultiplexOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("destinations", &self.destinations);
        formatter.field("id", &self.id);
        formatter.field("multiplex_settings", &self.multiplex_settings);
        formatter.field("name", &self.name);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("program_count", &self.program_count);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeMultiplexProgramResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMultiplexProgramOutputBody {
    /// The MediaLive channel associated with the program.
    #[serde(rename = "channelId")]
    #[serde(default)]
    pub channel_id: std::option::Option<std::string::String>,
    /// The settings for this multiplex program.
    #[serde(rename = "multiplexProgramSettings")]
    #[serde(default)]
    pub multiplex_program_settings: std::option::Option<crate::model::MultiplexProgramSettings>,
    /// The packet identifier map for this multiplex program.
    #[serde(rename = "packetIdentifiersMap")]
    #[serde(default)]
    pub packet_identifiers_map:
        std::option::Option<crate::model::MultiplexProgramPacketIdentifiersMap>,
    /// Contains information about the current sources for the specified program in the specified multiplex. Keep in mind that each multiplex pipeline connects to both pipelines in a given source channel (the channel identified by the program). But only one of those channel pipelines is ever active at one time.
    #[serde(rename = "pipelineDetails")]
    #[serde(default)]
    pub pipeline_details:
        std::option::Option<std::vec::Vec<crate::model::MultiplexProgramPipelineDetail>>,
    /// The name of the multiplex program.
    #[serde(rename = "programName")]
    #[serde(default)]
    pub program_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMultiplexProgramOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMultiplexProgramOutputBody");
        formatter.field("channel_id", &self.channel_id);
        formatter.field(
            "multiplex_program_settings",
            &self.multiplex_program_settings,
        );
        formatter.field("packet_identifiers_map", &self.packet_identifiers_map);
        formatter.field("pipeline_details", &self.pipeline_details);
        formatter.field("program_name", &self.program_name);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeOfferingResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeOfferingOutputBody {
    /// Unique offering ARN, e.g. 'arn:aws:medialive:us-west-2:123456789012:offering:87654321'
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// Currency code for usagePrice and fixedPrice in ISO-4217 format, e.g. 'USD'
    #[serde(rename = "currencyCode")]
    #[serde(default)]
    pub currency_code: std::option::Option<std::string::String>,
    /// Lease duration, e.g. '12'
    #[serde(rename = "duration")]
    #[serde(default)]
    pub duration: i32,
    /// Units for duration, e.g. 'MONTHS'
    #[serde(rename = "durationUnits")]
    #[serde(default)]
    pub duration_units: std::option::Option<crate::model::OfferingDurationUnits>,
    /// One-time charge for each reserved resource, e.g. '0.0' for a NO_UPFRONT offering
    #[serde(rename = "fixedPrice")]
    #[serde(default)]
    pub fixed_price: f64,
    /// Offering description, e.g. 'HD AVC output at 10-20 Mbps, 30 fps, and standard VQ in US West (Oregon)'
    #[serde(rename = "offeringDescription")]
    #[serde(default)]
    pub offering_description: std::option::Option<std::string::String>,
    /// Unique offering ID, e.g. '87654321'
    #[serde(rename = "offeringId")]
    #[serde(default)]
    pub offering_id: std::option::Option<std::string::String>,
    /// Offering type, e.g. 'NO_UPFRONT'
    #[serde(rename = "offeringType")]
    #[serde(default)]
    pub offering_type: std::option::Option<crate::model::OfferingType>,
    /// AWS region, e.g. 'us-west-2'
    #[serde(rename = "region")]
    #[serde(default)]
    pub region: std::option::Option<std::string::String>,
    /// Resource configuration details
    #[serde(rename = "resourceSpecification")]
    #[serde(default)]
    pub resource_specification: std::option::Option<crate::model::ReservationResourceSpecification>,
    /// Recurring usage charge for each reserved resource, e.g. '157.0'
    #[serde(rename = "usagePrice")]
    #[serde(default)]
    pub usage_price: f64,
}
impl std::fmt::Debug for DescribeOfferingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeOfferingOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("duration", &self.duration);
        formatter.field("duration_units", &self.duration_units);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("offering_description", &self.offering_description);
        formatter.field("offering_id", &self.offering_id);
        formatter.field("offering_type", &self.offering_type);
        formatter.field("region", &self.region);
        formatter.field("resource_specification", &self.resource_specification);
        formatter.field("usage_price", &self.usage_price);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeReservationResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeReservationOutputBody {
    /// Unique reservation ARN, e.g. 'arn:aws:medialive:us-west-2:123456789012:reservation:1234567'
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// Number of reserved resources
    #[serde(rename = "count")]
    #[serde(default)]
    pub count: i32,
    /// Currency code for usagePrice and fixedPrice in ISO-4217 format, e.g. 'USD'
    #[serde(rename = "currencyCode")]
    #[serde(default)]
    pub currency_code: std::option::Option<std::string::String>,
    /// Lease duration, e.g. '12'
    #[serde(rename = "duration")]
    #[serde(default)]
    pub duration: i32,
    /// Units for duration, e.g. 'MONTHS'
    #[serde(rename = "durationUnits")]
    #[serde(default)]
    pub duration_units: std::option::Option<crate::model::OfferingDurationUnits>,
    /// Reservation UTC end date and time in ISO-8601 format, e.g. '2019-03-01T00:00:00'
    #[serde(rename = "end")]
    #[serde(default)]
    pub end: std::option::Option<std::string::String>,
    /// One-time charge for each reserved resource, e.g. '0.0' for a NO_UPFRONT offering
    #[serde(rename = "fixedPrice")]
    #[serde(default)]
    pub fixed_price: f64,
    /// User specified reservation name
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// Offering description, e.g. 'HD AVC output at 10-20 Mbps, 30 fps, and standard VQ in US West (Oregon)'
    #[serde(rename = "offeringDescription")]
    #[serde(default)]
    pub offering_description: std::option::Option<std::string::String>,
    /// Unique offering ID, e.g. '87654321'
    #[serde(rename = "offeringId")]
    #[serde(default)]
    pub offering_id: std::option::Option<std::string::String>,
    /// Offering type, e.g. 'NO_UPFRONT'
    #[serde(rename = "offeringType")]
    #[serde(default)]
    pub offering_type: std::option::Option<crate::model::OfferingType>,
    /// AWS region, e.g. 'us-west-2'
    #[serde(rename = "region")]
    #[serde(default)]
    pub region: std::option::Option<std::string::String>,
    /// Unique reservation ID, e.g. '1234567'
    #[serde(rename = "reservationId")]
    #[serde(default)]
    pub reservation_id: std::option::Option<std::string::String>,
    /// Resource configuration details
    #[serde(rename = "resourceSpecification")]
    #[serde(default)]
    pub resource_specification: std::option::Option<crate::model::ReservationResourceSpecification>,
    /// Reservation UTC start date and time in ISO-8601 format, e.g. '2018-03-01T00:00:00'
    #[serde(rename = "start")]
    #[serde(default)]
    pub start: std::option::Option<std::string::String>,
    /// Current state of reservation, e.g. 'ACTIVE'
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::ReservationState>,
    /// A collection of key-value pairs
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Recurring usage charge for each reserved resource, e.g. '157.0'
    #[serde(rename = "usagePrice")]
    #[serde(default)]
    pub usage_price: f64,
}
impl std::fmt::Debug for DescribeReservationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeReservationOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("count", &self.count);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("duration", &self.duration);
        formatter.field("duration_units", &self.duration_units);
        formatter.field("end", &self.end);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("name", &self.name);
        formatter.field("offering_description", &self.offering_description);
        formatter.field("offering_id", &self.offering_id);
        formatter.field("offering_type", &self.offering_type);
        formatter.field("region", &self.region);
        formatter.field("reservation_id", &self.reservation_id);
        formatter.field("resource_specification", &self.resource_specification);
        formatter.field("start", &self.start);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("usage_price", &self.usage_price);
        formatter.finish()
    }
}

/// Placeholder documentation for DescribeScheduleResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeScheduleOutputBody {
    /// The next token; for use in pagination.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// The list of actions in the schedule.
    #[serde(rename = "scheduleActions")]
    #[serde(default)]
    pub schedule_actions: std::option::Option<std::vec::Vec<crate::model::ScheduleAction>>,
}
impl std::fmt::Debug for DescribeScheduleOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeScheduleOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("schedule_actions", &self.schedule_actions);
        formatter.finish()
    }
}

/// Placeholder documentation for ListChannelsResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsOutputBody {
    /// Placeholder documentation for __listOfChannelSummary
    #[serde(rename = "channels")]
    #[serde(default)]
    pub channels: std::option::Option<std::vec::Vec<crate::model::ChannelSummary>>,
    /// Placeholder documentation for __string
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsOutputBody");
        formatter.field("channels", &self.channels);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// Placeholder documentation for ListInputDevicesResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInputDevicesOutputBody {
    /// The list of input devices.
    #[serde(rename = "inputDevices")]
    #[serde(default)]
    pub input_devices: std::option::Option<std::vec::Vec<crate::model::InputDeviceSummary>>,
    /// A token to get additional list results.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListInputDevicesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInputDevicesOutputBody");
        formatter.field("input_devices", &self.input_devices);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// Placeholder documentation for ListInputDeviceTransfersResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInputDeviceTransfersOutputBody {
    /// The list of devices that you are transferring or are being transferred to you.
    #[serde(rename = "inputDeviceTransfers")]
    #[serde(default)]
    pub input_device_transfers:
        std::option::Option<std::vec::Vec<crate::model::TransferringInputDeviceSummary>>,
    /// A token to get additional list results.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListInputDeviceTransfersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInputDeviceTransfersOutputBody");
        formatter.field("input_device_transfers", &self.input_device_transfers);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// Placeholder documentation for ListInputsResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInputsOutputBody {
    /// Placeholder documentation for __listOfInput
    #[serde(rename = "inputs")]
    #[serde(default)]
    pub inputs: std::option::Option<std::vec::Vec<crate::model::Input>>,
    /// Placeholder documentation for __string
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListInputsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInputsOutputBody");
        formatter.field("inputs", &self.inputs);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// Placeholder documentation for ListInputSecurityGroupsResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInputSecurityGroupsOutputBody {
    /// List of input security groups
    #[serde(rename = "inputSecurityGroups")]
    #[serde(default)]
    pub input_security_groups: std::option::Option<std::vec::Vec<crate::model::InputSecurityGroup>>,
    /// Placeholder documentation for __string
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListInputSecurityGroupsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInputSecurityGroupsOutputBody");
        formatter.field("input_security_groups", &self.input_security_groups);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// Placeholder documentation for ListMultiplexesResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMultiplexesOutputBody {
    /// List of multiplexes.
    #[serde(rename = "multiplexes")]
    #[serde(default)]
    pub multiplexes: std::option::Option<std::vec::Vec<crate::model::MultiplexSummary>>,
    /// Token for the next ListMultiplexes request.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListMultiplexesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMultiplexesOutputBody");
        formatter.field("multiplexes", &self.multiplexes);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// Placeholder documentation for ListMultiplexProgramsResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMultiplexProgramsOutputBody {
    /// List of multiplex programs.
    #[serde(rename = "multiplexPrograms")]
    #[serde(default)]
    pub multiplex_programs:
        std::option::Option<std::vec::Vec<crate::model::MultiplexProgramSummary>>,
    /// Token for the next ListMultiplexProgram request.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListMultiplexProgramsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMultiplexProgramsOutputBody");
        formatter.field("multiplex_programs", &self.multiplex_programs);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// Placeholder documentation for ListOfferingsResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOfferingsOutputBody {
    /// Token to retrieve the next page of results
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// List of offerings
    #[serde(rename = "offerings")]
    #[serde(default)]
    pub offerings: std::option::Option<std::vec::Vec<crate::model::Offering>>,
}
impl std::fmt::Debug for ListOfferingsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOfferingsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("offerings", &self.offerings);
        formatter.finish()
    }
}

/// Placeholder documentation for ListReservationsResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListReservationsOutputBody {
    /// Token to retrieve the next page of results
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// List of reservations
    #[serde(rename = "reservations")]
    #[serde(default)]
    pub reservations: std::option::Option<std::vec::Vec<crate::model::Reservation>>,
}
impl std::fmt::Debug for ListReservationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListReservationsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("reservations", &self.reservations);
        formatter.finish()
    }
}

/// Placeholder documentation for ListTagsForResourceResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutputBody {
    /// Placeholder documentation for Tags
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ListTagsForResourceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Placeholder documentation for PurchaseOfferingResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PurchaseOfferingOutputBody {
    /// Reserved resources available to use
    #[serde(rename = "reservation")]
    #[serde(default)]
    pub reservation: std::option::Option<crate::model::Reservation>,
}
impl std::fmt::Debug for PurchaseOfferingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PurchaseOfferingOutputBody");
        formatter.field("reservation", &self.reservation);
        formatter.finish()
    }
}

/// Placeholder documentation for StartChannelResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartChannelOutputBody {
    /// The unique arn of the channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// Specification of CDI inputs for this channel
    #[serde(rename = "cdiInputSpecification")]
    #[serde(default)]
    pub cdi_input_specification: std::option::Option<crate::model::CdiInputSpecification>,
    /// The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
    #[serde(rename = "channelClass")]
    #[serde(default)]
    pub channel_class: std::option::Option<crate::model::ChannelClass>,
    /// A list of destinations of the channel. For UDP outputs, there is one
    /// destination per output. For other types (HLS, for example), there is
    /// one destination per packager.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
    /// The endpoints where outgoing connections initiate from
    #[serde(rename = "egressEndpoints")]
    #[serde(default)]
    pub egress_endpoints: std::option::Option<std::vec::Vec<crate::model::ChannelEgressEndpoint>>,
    /// Encoder Settings
    #[serde(rename = "encoderSettings")]
    #[serde(default)]
    pub encoder_settings: std::option::Option<crate::model::EncoderSettings>,
    /// The unique id of the channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// List of input attachments for channel.
    #[serde(rename = "inputAttachments")]
    #[serde(default)]
    pub input_attachments: std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
    /// Specification of network and file inputs for this channel
    #[serde(rename = "inputSpecification")]
    #[serde(default)]
    pub input_specification: std::option::Option<crate::model::InputSpecification>,
    /// The log level being written to CloudWatch Logs.
    #[serde(rename = "logLevel")]
    #[serde(default)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
    /// The name of the channel. (user-mutable)
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// Runtime details for the pipelines of a running channel.
    #[serde(rename = "pipelineDetails")]
    #[serde(default)]
    pub pipeline_details: std::option::Option<std::vec::Vec<crate::model::PipelineDetail>>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The Amazon Resource Name (ARN) of the role assumed when running the Channel.
    #[serde(rename = "roleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// Placeholder documentation for ChannelState
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::ChannelState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Settings for VPC output
    #[serde(rename = "vpc")]
    #[serde(default)]
    pub vpc: std::option::Option<crate::model::VpcOutputSettingsDescription>,
}
impl std::fmt::Debug for StartChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartChannelOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("cdi_input_specification", &self.cdi_input_specification);
        formatter.field("channel_class", &self.channel_class);
        formatter.field("destinations", &self.destinations);
        formatter.field("egress_endpoints", &self.egress_endpoints);
        formatter.field("encoder_settings", &self.encoder_settings);
        formatter.field("id", &self.id);
        formatter.field("input_attachments", &self.input_attachments);
        formatter.field("input_specification", &self.input_specification);
        formatter.field("log_level", &self.log_level);
        formatter.field("name", &self.name);
        formatter.field("pipeline_details", &self.pipeline_details);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("vpc", &self.vpc);
        formatter.finish()
    }
}

/// Placeholder documentation for StartMultiplexResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartMultiplexOutputBody {
    /// The unique arn of the multiplex.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A list of availability zones for the multiplex.
    #[serde(rename = "availabilityZones")]
    #[serde(default)]
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the multiplex output destinations.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::MultiplexOutputDestination>>,
    /// The unique id of the multiplex.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configuration for a multiplex event.
    #[serde(rename = "multiplexSettings")]
    #[serde(default)]
    pub multiplex_settings: std::option::Option<crate::model::MultiplexSettings>,
    /// The name of the multiplex.
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The number of programs in the multiplex.
    #[serde(rename = "programCount")]
    #[serde(default)]
    pub program_count: i32,
    /// The current state of the multiplex.
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::MultiplexState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for StartMultiplexOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartMultiplexOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("destinations", &self.destinations);
        formatter.field("id", &self.id);
        formatter.field("multiplex_settings", &self.multiplex_settings);
        formatter.field("name", &self.name);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("program_count", &self.program_count);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Placeholder documentation for StopChannelResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StopChannelOutputBody {
    /// The unique arn of the channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// Specification of CDI inputs for this channel
    #[serde(rename = "cdiInputSpecification")]
    #[serde(default)]
    pub cdi_input_specification: std::option::Option<crate::model::CdiInputSpecification>,
    /// The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
    #[serde(rename = "channelClass")]
    #[serde(default)]
    pub channel_class: std::option::Option<crate::model::ChannelClass>,
    /// A list of destinations of the channel. For UDP outputs, there is one
    /// destination per output. For other types (HLS, for example), there is
    /// one destination per packager.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::OutputDestination>>,
    /// The endpoints where outgoing connections initiate from
    #[serde(rename = "egressEndpoints")]
    #[serde(default)]
    pub egress_endpoints: std::option::Option<std::vec::Vec<crate::model::ChannelEgressEndpoint>>,
    /// Encoder Settings
    #[serde(rename = "encoderSettings")]
    #[serde(default)]
    pub encoder_settings: std::option::Option<crate::model::EncoderSettings>,
    /// The unique id of the channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// List of input attachments for channel.
    #[serde(rename = "inputAttachments")]
    #[serde(default)]
    pub input_attachments: std::option::Option<std::vec::Vec<crate::model::InputAttachment>>,
    /// Specification of network and file inputs for this channel
    #[serde(rename = "inputSpecification")]
    #[serde(default)]
    pub input_specification: std::option::Option<crate::model::InputSpecification>,
    /// The log level being written to CloudWatch Logs.
    #[serde(rename = "logLevel")]
    #[serde(default)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
    /// The name of the channel. (user-mutable)
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// Runtime details for the pipelines of a running channel.
    #[serde(rename = "pipelineDetails")]
    #[serde(default)]
    pub pipeline_details: std::option::Option<std::vec::Vec<crate::model::PipelineDetail>>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The Amazon Resource Name (ARN) of the role assumed when running the Channel.
    #[serde(rename = "roleArn")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// Placeholder documentation for ChannelState
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::ChannelState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Settings for VPC output
    #[serde(rename = "vpc")]
    #[serde(default)]
    pub vpc: std::option::Option<crate::model::VpcOutputSettingsDescription>,
}
impl std::fmt::Debug for StopChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopChannelOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("cdi_input_specification", &self.cdi_input_specification);
        formatter.field("channel_class", &self.channel_class);
        formatter.field("destinations", &self.destinations);
        formatter.field("egress_endpoints", &self.egress_endpoints);
        formatter.field("encoder_settings", &self.encoder_settings);
        formatter.field("id", &self.id);
        formatter.field("input_attachments", &self.input_attachments);
        formatter.field("input_specification", &self.input_specification);
        formatter.field("log_level", &self.log_level);
        formatter.field("name", &self.name);
        formatter.field("pipeline_details", &self.pipeline_details);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("vpc", &self.vpc);
        formatter.finish()
    }
}

/// Placeholder documentation for StopMultiplexResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StopMultiplexOutputBody {
    /// The unique arn of the multiplex.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A list of availability zones for the multiplex.
    #[serde(rename = "availabilityZones")]
    #[serde(default)]
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// A list of the multiplex output destinations.
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::MultiplexOutputDestination>>,
    /// The unique id of the multiplex.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configuration for a multiplex event.
    #[serde(rename = "multiplexSettings")]
    #[serde(default)]
    pub multiplex_settings: std::option::Option<crate::model::MultiplexSettings>,
    /// The name of the multiplex.
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// The number of currently healthy pipelines.
    #[serde(rename = "pipelinesRunningCount")]
    #[serde(default)]
    pub pipelines_running_count: i32,
    /// The number of programs in the multiplex.
    #[serde(rename = "programCount")]
    #[serde(default)]
    pub program_count: i32,
    /// The current state of the multiplex.
    #[serde(rename = "state")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::MultiplexState>,
    /// A collection of key-value pairs.
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for StopMultiplexOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopMultiplexOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("destinations", &self.destinations);
        formatter.field("id", &self.id);
        formatter.field("multiplex_settings", &self.multiplex_settings);
        formatter.field("name", &self.name);
        formatter.field("pipelines_running_count", &self.pipelines_running_count);
        formatter.field("program_count", &self.program_count);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateChannelResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelOutputBody {
    /// Placeholder documentation for Channel
    #[serde(rename = "channel")]
    #[serde(default)]
    pub channel: std::option::Option<crate::model::Channel>,
}
impl std::fmt::Debug for UpdateChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelOutputBody");
        formatter.field("channel", &self.channel);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateChannelClassResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelClassOutputBody {
    /// Placeholder documentation for Channel
    #[serde(rename = "channel")]
    #[serde(default)]
    pub channel: std::option::Option<crate::model::Channel>,
}
impl std::fmt::Debug for UpdateChannelClassOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelClassOutputBody");
        formatter.field("channel", &self.channel);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateInputResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInputOutputBody {
    /// Placeholder documentation for Input
    #[serde(rename = "input")]
    #[serde(default)]
    pub input: std::option::Option<crate::model::Input>,
}
impl std::fmt::Debug for UpdateInputOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInputOutputBody");
        formatter.field("input", &self.input);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateInputDeviceResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInputDeviceOutputBody {
    /// The unique ARN of the input device.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// The state of the connection between the input device and AWS.
    #[serde(rename = "connectionState")]
    #[serde(default)]
    pub connection_state: std::option::Option<crate::model::InputDeviceConnectionState>,
    /// The status of the action to synchronize the device configuration. If you change the configuration of the input device (for example, the maximum bitrate), MediaLive sends the new data to the device. The device might not update itself immediately. SYNCED means the device has updated its configuration. SYNCING means that it has not updated its configuration.
    #[serde(rename = "deviceSettingsSyncState")]
    #[serde(default)]
    pub device_settings_sync_state: std::option::Option<crate::model::DeviceSettingsSyncState>,
    /// The status of software on the input device.
    #[serde(rename = "deviceUpdateStatus")]
    #[serde(default)]
    pub device_update_status: std::option::Option<crate::model::DeviceUpdateStatus>,
    /// Settings that describe an input device that is type HD.
    #[serde(rename = "hdDeviceSettings")]
    #[serde(default)]
    pub hd_device_settings: std::option::Option<crate::model::InputDeviceHdSettings>,
    /// The unique ID of the input device.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// The network MAC address of the input device.
    #[serde(rename = "macAddress")]
    #[serde(default)]
    pub mac_address: std::option::Option<std::string::String>,
    /// A name that you specify for the input device.
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// The network settings for the input device.
    #[serde(rename = "networkSettings")]
    #[serde(default)]
    pub network_settings: std::option::Option<crate::model::InputDeviceNetworkSettings>,
    /// The unique serial number of the input device.
    #[serde(rename = "serialNumber")]
    #[serde(default)]
    pub serial_number: std::option::Option<std::string::String>,
    /// The type of the input device.
    #[serde(rename = "type")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::InputDeviceType>,
    /// Settings that describe an input device that is type UHD.
    #[serde(rename = "uhdDeviceSettings")]
    #[serde(default)]
    pub uhd_device_settings: std::option::Option<crate::model::InputDeviceUhdSettings>,
}
impl std::fmt::Debug for UpdateInputDeviceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInputDeviceOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("connection_state", &self.connection_state);
        formatter.field(
            "device_settings_sync_state",
            &self.device_settings_sync_state,
        );
        formatter.field("device_update_status", &self.device_update_status);
        formatter.field("hd_device_settings", &self.hd_device_settings);
        formatter.field("id", &self.id);
        formatter.field("mac_address", &self.mac_address);
        formatter.field("name", &self.name);
        formatter.field("network_settings", &self.network_settings);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("r#type", &self.r#type);
        formatter.field("uhd_device_settings", &self.uhd_device_settings);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateInputSecurityGroupResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInputSecurityGroupOutputBody {
    /// An Input Security Group
    #[serde(rename = "securityGroup")]
    #[serde(default)]
    pub security_group: std::option::Option<crate::model::InputSecurityGroup>,
}
impl std::fmt::Debug for UpdateInputSecurityGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInputSecurityGroupOutputBody");
        formatter.field("security_group", &self.security_group);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateMultiplexResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMultiplexOutputBody {
    /// The updated multiplex.
    #[serde(rename = "multiplex")]
    #[serde(default)]
    pub multiplex: std::option::Option<crate::model::Multiplex>,
}
impl std::fmt::Debug for UpdateMultiplexOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMultiplexOutputBody");
        formatter.field("multiplex", &self.multiplex);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateMultiplexProgramResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMultiplexProgramOutputBody {
    /// The updated multiplex program.
    #[serde(rename = "multiplexProgram")]
    #[serde(default)]
    pub multiplex_program: std::option::Option<crate::model::MultiplexProgram>,
}
impl std::fmt::Debug for UpdateMultiplexProgramOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMultiplexProgramOutputBody");
        formatter.field("multiplex_program", &self.multiplex_program);
        formatter.finish()
    }
}

/// Placeholder documentation for UpdateReservationResponse
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateReservationOutputBody {
    /// Reserved resources available to use
    #[serde(rename = "reservation")]
    #[serde(default)]
    pub reservation: std::option::Option<crate::model::Reservation>,
}
impl std::fmt::Debug for UpdateReservationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateReservationOutputBody");
        formatter.field("reservation", &self.reservation);
        formatter.finish()
    }
}
