// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Contains the parameters for <code>CancelJob</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelJobInputBody<'a> {
    /// <p>The AWS Batch job ID of the job to cancel.</p>
    pub job_id: &'a std::option::Option<std::string::String>,
    /// <p>A message to attach to the job that explains the reason for canceling it. This message is returned by future
    /// <a>DescribeJobs</a> operations on the job. This message is also recorded in the AWS Batch activity
    /// logs.</p>
    pub reason: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CancelJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelJobInputBody");
        formatter.field("job_id", &self.job_id);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>CreateComputeEnvironment</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateComputeEnvironmentInputBody<'a> {
    /// <p>The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, hyphens, and
    /// underscores are allowed.</p>
    pub compute_environment_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of the compute environment: <code>MANAGED</code> or <code>UNMANAGED</code>. For more information, see
    /// <a href="https://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html">Compute Environments</a> in the
    /// <i>AWS Batch User Guide</i>.</p>
    pub r#type: &'a std::option::Option<crate::model::CeType>,
    /// <p>The state of the compute environment. If the state is <code>ENABLED</code>, then the compute environment accepts
    /// jobs from a queue and can scale out automatically based on queues.</p>
    /// <p>If the state is <code>ENABLED</code>, then the AWS Batch scheduler can attempt to place jobs from an associated
    /// job queue on the compute resources within the environment. If the compute environment is managed, then it can scale
    /// its instances out or in automatically, based on the job queue demand.</p>
    /// <p>If the state is <code>DISABLED</code>, then the AWS Batch scheduler doesn't attempt to place jobs within the
    /// environment. Jobs in a <code>STARTING</code> or <code>RUNNING</code> state continue to progress normally. Managed
    /// compute environments in the <code>DISABLED</code> state don't scale out. However, they scale in to
    /// <code>minvCpus</code> value after instances become idle.</p>
    pub state: &'a std::option::Option<crate::model::CeState>,
    /// <p>Details about the compute resources managed by the compute environment. This parameter is required for managed
    /// compute environments. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html">Compute Environments</a> in the <i>AWS Batch User Guide</i>.</p>
    pub compute_resources: &'a std::option::Option<crate::model::ComputeResource>,
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf. For
    /// more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/service_IAM_role.html">AWS Batch service IAM
    /// role</a> in the <i>AWS Batch User Guide</i>.</p>
    /// <important>
    /// <p>If your account has already created the AWS Batch service-linked role, that role is used by default for your
    /// compute environment unless you specify a role here. If the AWS Batch service-linked role does not exist in your
    /// account, and no role is specified here, the service will try to create the AWS Batch service-linked role in your
    /// account.</p>
    /// </important>
    /// <p>If your specified role has a path other than <code>/</code>, then you must specify either the full role ARN
    /// (recommended) or prefix the role name with the path. For example, if a role with the name <code>bar</code> has a path
    /// of <code>/foo/</code> then you would specify <code>/foo/bar</code> as the role name. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names">Friendly names
    /// and paths</a> in the <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>Depending on how you created your AWS Batch service role, its ARN might contain the <code>service-role</code>
    /// path prefix. When you only specify the name of the service role, AWS Batch assumes that your ARN doesn't use the
    /// <code>service-role</code> path prefix. Because of this, we recommend that you specify the full ARN of your service
    /// role when you create compute environments.</p>
    /// </note>
    pub service_role: &'a std::option::Option<std::string::String>,
    /// <p>The tags that you apply to the compute environment to help you categorize and organize your resources. Each tag
    /// consists of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS Resources</a> in <i>AWS General
    /// Reference</i>.</p>
    /// <p>These tags can be updated or removed using the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_TagResource.html">TagResource</a> and <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_UntagResource.html">UntagResource</a> API operations. These tags don't
    /// propagate to the underlying compute resources.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for CreateComputeEnvironmentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateComputeEnvironmentInputBody");
        formatter.field("compute_environment_name", &self.compute_environment_name);
        formatter.field("r#type", &self.r#type);
        formatter.field("state", &self.state);
        formatter.field("compute_resources", &self.compute_resources);
        formatter.field("service_role", &self.service_role);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>CreateJobQueue</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateJobQueueInputBody<'a> {
    /// <p>The name of the job queue. Up to 128 letters (uppercase and lowercase), numbers, and underscores are
    /// allowed.</p>
    pub job_queue_name: &'a std::option::Option<std::string::String>,
    /// <p>The state of the job queue. If the job queue state is <code>ENABLED</code>, it is able to accept jobs. If the
    /// job queue state is <code>DISABLED</code>, new jobs can't be added to the queue, but jobs already in the queue can
    /// finish.</p>
    pub state: &'a std::option::Option<crate::model::JqState>,
    /// <p>The priority of the job queue. Job queues with a higher priority (or a higher integer value for the
    /// <code>priority</code> parameter) are evaluated first when associated with the same compute environment. Priority is
    /// determined in descending order. For example, a job queue with a priority value of <code>10</code> is given scheduling
    /// preference over a job queue with a priority value of <code>1</code>. All of the compute environments must be either
    /// EC2 (<code>EC2</code> or <code>SPOT</code>) or Fargate (<code>FARGATE</code> or <code>FARGATE_SPOT</code>); EC2 and
    /// Fargate compute environments cannot be mixed.</p>
    pub priority: &'a i32,
    /// <p>The set of compute environments mapped to a job queue and their order relative to each other. The job scheduler
    /// uses this parameter to determine which compute environment should run a specific job. Compute environments must be in
    /// the <code>VALID</code> state before you can associate them with a job queue. You can associate up to three compute
    /// environments with a job queue. All of the compute environments must be either EC2 (<code>EC2</code> or
    /// <code>SPOT</code>) or Fargate (<code>FARGATE</code> or <code>FARGATE_SPOT</code>); EC2 and Fargate compute
    /// environments can't be mixed.</p>
    /// <note>
    /// <p>All compute environments that are associated with a job queue must share the same architecture. AWS Batch doesn't
    /// support mixing compute environment architecture types in a single job queue.</p>
    /// </note>
    pub compute_environment_order:
        &'a std::option::Option<std::vec::Vec<crate::model::ComputeEnvironmentOrder>>,
    /// <p>The tags that you apply to the job queue to help you categorize and organize your resources. Each tag consists
    /// of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/using-tags.html">Tagging your AWS Batch resources</a> in <i>AWS Batch User Guide</i>.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for CreateJobQueueInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateJobQueueInputBody");
        formatter.field("job_queue_name", &self.job_queue_name);
        formatter.field("state", &self.state);
        formatter.field("priority", &self.priority);
        formatter.field("compute_environment_order", &self.compute_environment_order);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>DeleteComputeEnvironment</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteComputeEnvironmentInputBody<'a> {
    /// <p>The name or Amazon Resource Name (ARN) of the compute environment to delete.</p>
    pub compute_environment: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteComputeEnvironmentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteComputeEnvironmentInputBody");
        formatter.field("compute_environment", &self.compute_environment);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>DeleteJobQueue</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteJobQueueInputBody<'a> {
    /// <p>The short name or full Amazon Resource Name (ARN) of the queue to delete.</p>
    pub job_queue: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteJobQueueInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteJobQueueInputBody");
        formatter.field("job_queue", &self.job_queue);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterJobDefinitionInputBody<'a> {
    /// <p>The name and revision (<code>name:revision</code>) or full Amazon Resource Name (ARN) of the job definition to deregister.</p>
    pub job_definition: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeregisterJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterJobDefinitionInputBody");
        formatter.field("job_definition", &self.job_definition);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>DescribeComputeEnvironments</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeComputeEnvironmentsInputBody<'a> {
    /// <p>A list of up to 100 compute environment names or full Amazon Resource Name (ARN) entries.</p>
    pub compute_environments: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of cluster results returned by <code>DescribeComputeEnvironments</code> in paginated output.
    /// When this parameter is used, <code>DescribeComputeEnvironments</code> only returns <code>maxResults</code> results in
    /// a single page along with a <code>nextToken</code> response element. The remaining results of the initial request can
    /// be seen by sending another <code>DescribeComputeEnvironments</code> request with the returned <code>nextToken</code>
    /// value. This value can be between 1 and 100. If this parameter isn't used, then
    /// <code>DescribeComputeEnvironments</code> returns up to 100 results and a <code>nextToken</code>
    /// value if applicable.</p>
    pub max_results: &'a i32,
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>DescribeComputeEnvironments</code>
    /// request where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination
    /// continues from the end of the previous results that returned the <code>nextToken</code> value. This value is
    /// <code>null</code> when there are no more results to return.</p>
    /// <note>
    /// <p>This token should be treated as an opaque identifier that's only used to
    /// retrieve the next items in a list and not for other programmatic purposes.</p>
    /// </note>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeComputeEnvironmentsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeComputeEnvironmentsInputBody");
        formatter.field("compute_environments", &self.compute_environments);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>DescribeJobDefinitions</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobDefinitionsInputBody<'a> {
    /// <p>A list of up to 100 job definition names or full Amazon Resource Name (ARN) entries.</p>
    pub job_definitions: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results returned by <code>DescribeJobDefinitions</code> in paginated output. When this
    /// parameter is used, <code>DescribeJobDefinitions</code> only returns <code>maxResults</code> results in a single page
    /// and a <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending
    /// another <code>DescribeJobDefinitions</code> request with the returned <code>nextToken</code> value. This value can be
    /// between 1 and 100. If this parameter isn't used, then
    /// <code>DescribeJobDefinitions</code> returns up to 100 results and a <code>nextToken</code> value
    /// if applicable.</p>
    pub max_results: &'a i32,
    /// <p>The name of the job definition to describe.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>The status used to filter job definitions.</p>
    pub status: &'a std::option::Option<std::string::String>,
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>DescribeJobDefinitions</code> request
    /// where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues
    /// from the end of the previous results that returned the <code>nextToken</code> value. This value is <code>null</code>
    /// when there are no more results to return.</p>
    /// <note>
    /// <p>This token should be treated as an opaque identifier that's only used to
    /// retrieve the next items in a list and not for other programmatic purposes.</p>
    /// </note>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeJobDefinitionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobDefinitionsInputBody");
        formatter.field("job_definitions", &self.job_definitions);
        formatter.field("max_results", &self.max_results);
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field("status", &self.status);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>DescribeJobQueues</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobQueuesInputBody<'a> {
    /// <p>A list of up to 100 queue names or full queue Amazon Resource Name (ARN) entries.</p>
    pub job_queues: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results returned by <code>DescribeJobQueues</code> in paginated output. When this
    /// parameter is used, <code>DescribeJobQueues</code> only returns <code>maxResults</code> results in a single page and a
    /// <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another
    /// <code>DescribeJobQueues</code> request with the returned <code>nextToken</code> value. This value can be between
    /// 1 and 100. If this parameter isn't used, then <code>DescribeJobQueues</code> returns up
    /// to 100 results and a <code>nextToken</code> value if applicable.</p>
    pub max_results: &'a i32,
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>DescribeJobQueues</code> request where
    /// <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the
    /// end of the previous results that returned the <code>nextToken</code> value. This value is <code>null</code> when
    /// there are no more results to return.</p>
    /// <note>
    /// <p>This token should be treated as an opaque identifier that's only used to
    /// retrieve the next items in a list and not for other programmatic purposes.</p>
    /// </note>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeJobQueuesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobQueuesInputBody");
        formatter.field("job_queues", &self.job_queues);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>DescribeJobs</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobsInputBody<'a> {
    /// <p>A list of up to 100 job IDs.</p>
    pub jobs: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for DescribeJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobsInputBody");
        formatter.field("jobs", &self.jobs);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>ListJobs</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobsInputBody<'a> {
    /// <p>The name or full Amazon Resource Name (ARN) of the job queue used to list jobs.</p>
    pub job_queue: &'a std::option::Option<std::string::String>,
    /// <p>The job ID for an array job. Specifying an array job ID with this parameter lists all child jobs from within the
    /// specified array.</p>
    pub array_job_id: &'a std::option::Option<std::string::String>,
    /// <p>The job ID for a multi-node parallel job. Specifying a multi-node parallel job ID with this parameter lists all
    /// nodes that are associated with the specified job.</p>
    pub multi_node_job_id: &'a std::option::Option<std::string::String>,
    /// <p>The job status used to filter jobs in the specified queue. If you don't specify a status, only
    /// <code>RUNNING</code> jobs are returned.</p>
    pub job_status: &'a std::option::Option<crate::model::JobStatus>,
    /// <p>The maximum number of results returned by <code>ListJobs</code> in paginated output. When this parameter is
    /// used, <code>ListJobs</code> only returns <code>maxResults</code> results in a single page and a
    /// <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another
    /// <code>ListJobs</code> request with the returned <code>nextToken</code> value. This value can be between
    /// 1 and 100. If this parameter isn't used, then <code>ListJobs</code> returns up to
    /// 100 results and a <code>nextToken</code> value if applicable.</p>
    pub max_results: &'a i32,
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>ListJobs</code> request where
    /// <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the
    /// end of the previous results that returned the <code>nextToken</code> value. This value is <code>null</code> when
    /// there are no more results to return.</p>
    /// <note>
    /// <p>This token should be treated as an opaque identifier that's only used to
    /// retrieve the next items in a list and not for other programmatic purposes.</p>
    /// </note>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobsInputBody");
        formatter.field("job_queue", &self.job_queue);
        formatter.field("array_job_id", &self.array_job_id);
        formatter.field("multi_node_job_id", &self.multi_node_job_id);
        formatter.field("job_status", &self.job_status);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>RegisterJobDefinition</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterJobDefinitionInputBody<'a> {
    /// <p>The name of the job definition to register. Up to 128 letters (uppercase and lowercase), numbers, hyphens, and
    /// underscores are allowed.</p>
    pub job_definition_name: &'a std::option::Option<std::string::String>,
    /// <p>The type of job definition. For more information about multi-node parallel jobs, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/multi-node-job-def.html">Creating a multi-node parallel job definition</a> in the
    /// <i>AWS Batch User Guide</i>.</p>
    /// <note>
    /// <p>If the job is run on Fargate resources, then <code>multinode</code> isn't supported.</p>
    /// </note>
    pub r#type: &'a std::option::Option<crate::model::JobDefinitionType>,
    /// <p>Default parameter substitution placeholders to set in the job definition. Parameters are specified as a
    /// key-value pair mapping. Parameters in a <code>SubmitJob</code> request override any corresponding parameter defaults
    /// from the job definition.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>An object with various properties specific to single-node container-based jobs. If the job definition's
    /// <code>type</code> parameter is <code>container</code>, then you must specify either <code>containerProperties</code>
    /// or <code>nodeProperties</code>.</p>
    /// <note>
    /// <p>If the job runs on Fargate resources, then you must not specify <code>nodeProperties</code>; use only
    /// <code>containerProperties</code>.</p>
    /// </note>
    pub container_properties: &'a std::option::Option<crate::model::ContainerProperties>,
    /// <p>An object with various properties specific to multi-node parallel jobs. If you specify node properties for a
    /// job, it becomes a multi-node parallel job. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/multi-node-parallel-jobs.html">Multi-node Parallel Jobs</a> in the
    /// <i>AWS Batch User Guide</i>. If the job definition's <code>type</code> parameter is
    /// <code>container</code>, then you must specify either <code>containerProperties</code> or
    /// <code>nodeProperties</code>.</p>
    /// <note>
    /// <p>If the job runs on Fargate resources, then you must not specify <code>nodeProperties</code>; use
    /// <code>containerProperties</code> instead.</p>
    /// </note>
    pub node_properties: &'a std::option::Option<crate::model::NodeProperties>,
    /// <p>The retry strategy to use for failed jobs that are submitted with this job definition. Any retry strategy that's
    /// specified during a <a>SubmitJob</a> operation overrides the retry strategy defined here. If a job is
    /// terminated due to a timeout, it isn't retried.</p>
    pub retry_strategy: &'a std::option::Option<crate::model::RetryStrategy>,
    /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no
    /// value is specified, the tags are not propagated. Tags can only be propagated to the tasks during task creation. For
    /// tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags
    /// from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state.</p>
    pub propagate_tags: &'a bool,
    /// <p>The timeout configuration for jobs that are submitted with this job definition, after which AWS Batch terminates
    /// your jobs if they have not finished. If a job is terminated due to a timeout, it isn't retried. The minimum value for
    /// the timeout is 60 seconds. Any timeout configuration that's specified during a <a>SubmitJob</a> operation
    /// overrides the timeout configuration defined here. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/job_timeouts.html">Job Timeouts</a> in the <i>AWS Batch User Guide</i>.</p>
    pub timeout: &'a std::option::Option<crate::model::JobTimeout>,
    /// <p>The tags that you apply to the job definition to help you categorize and organize your resources. Each tag
    /// consists of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/using-tags.html">Tagging AWS Resources</a> in <i>AWS Batch User Guide</i>.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>The platform capabilities required by the job definition. If no value is specified, it defaults to
    /// <code>EC2</code>. To run the job on Fargate resources, specify <code>FARGATE</code>.</p>
    pub platform_capabilities:
        &'a std::option::Option<std::vec::Vec<crate::model::PlatformCapability>>,
}
impl<'a> std::fmt::Debug for RegisterJobDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterJobDefinitionInputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field("r#type", &self.r#type);
        formatter.field("parameters", &self.parameters);
        formatter.field("container_properties", &self.container_properties);
        formatter.field("node_properties", &self.node_properties);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.field("propagate_tags", &self.propagate_tags);
        formatter.field("timeout", &self.timeout);
        formatter.field("tags", &self.tags);
        formatter.field("platform_capabilities", &self.platform_capabilities);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>SubmitJob</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubmitJobInputBody<'a> {
    /// <p>The name of the job. The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase),
    /// numbers, hyphens, and underscores are allowed.</p>
    pub job_name: &'a std::option::Option<std::string::String>,
    /// <p>The job queue where the job is submitted. You can specify either the name or the Amazon Resource Name (ARN) of the queue.</p>
    pub job_queue: &'a std::option::Option<std::string::String>,
    /// <p>The array properties for the submitted job, such as the size of the array. The array size can be between 2 and
    /// 10,000. If you specify array properties for a job, it becomes an array job. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/array_jobs.html">Array Jobs</a> in the
    /// <i>AWS Batch User Guide</i>.</p>
    pub array_properties: &'a std::option::Option<crate::model::ArrayProperties>,
    /// <p>A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. You can specify a
    /// <code>SEQUENTIAL</code> type dependency without specifying a job ID for array jobs so that each child array job
    /// completes sequentially, starting at index 0. You can also specify an <code>N_TO_N</code> type dependency with a job
    /// ID for array jobs. In that case, each index child of this job must wait for the corresponding index child of each
    /// dependency to complete before it can begin.</p>
    pub depends_on: &'a std::option::Option<std::vec::Vec<crate::model::JobDependency>>,
    /// <p>The job definition used by this job. This value can be one of <code>name</code>, <code>name:revision</code>, or
    /// the Amazon Resource Name (ARN) for the job definition. If <code>name</code> is specified without a revision then the latest active
    /// revision is used.</p>
    pub job_definition: &'a std::option::Option<std::string::String>,
    /// <p>Additional parameters passed to the job that replace parameter substitution placeholders that are set in the job
    /// definition. Parameters are specified as a key and value pair mapping. Parameters in a <code>SubmitJob</code> request
    /// override any corresponding parameter defaults from the job definition.</p>
    pub parameters: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>A list of container overrides in the JSON format that specify the name of a container in the specified job
    /// definition and the overrides it should receive. You can override the default command for a container, which is
    /// specified in the job definition or the Docker image, with a <code>command</code> override. You can also override
    /// existing environment variables on a container or add new environment variables to it with an <code>environment</code>
    /// override.</p>
    pub container_overrides: &'a std::option::Option<crate::model::ContainerOverrides>,
    /// <p>A list of node overrides in JSON format that specify the node range to target and the container overrides for
    /// that node range.</p>
    /// <note>
    /// <p>This parameter isn't applicable to jobs running on Fargate resources; use <code>containerOverrides</code>
    /// instead.</p>
    /// </note>
    pub node_overrides: &'a std::option::Option<crate::model::NodeOverrides>,
    /// <p>The retry strategy to use for failed jobs from this <a>SubmitJob</a> operation. When a retry strategy
    /// is specified here, it overrides the retry strategy defined in the job definition.</p>
    pub retry_strategy: &'a std::option::Option<crate::model::RetryStrategy>,
    /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no
    /// value is specified, the tags aren't propagated. Tags can only be propagated to the tasks during task creation. For
    /// tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags
    /// from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state. When specified, this
    /// overrides the tag propagation setting in the job definition.</p>
    pub propagate_tags: &'a bool,
    /// <p>The timeout configuration for this <a>SubmitJob</a> operation. You can specify a timeout duration
    /// after which AWS Batch terminates your jobs if they haven't finished. If a job is terminated due to a timeout, it isn't
    /// retried. The minimum value for the timeout is 60 seconds. This configuration overrides any timeout configuration
    /// specified in the job definition. For array jobs, child jobs have the same timeout configuration as the parent job.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/job_timeouts.html">Job
    /// Timeouts</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub timeout: &'a std::option::Option<crate::model::JobTimeout>,
    /// <p>The tags that you apply to the job request to help you categorize and organize your resources. Each tag consists
    /// of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS Resources</a> in <i>AWS General
    /// Reference</i>.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for SubmitJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubmitJobInputBody");
        formatter.field("job_name", &self.job_name);
        formatter.field("job_queue", &self.job_queue);
        formatter.field("array_properties", &self.array_properties);
        formatter.field("depends_on", &self.depends_on);
        formatter.field("job_definition", &self.job_definition);
        formatter.field("parameters", &self.parameters);
        formatter.field("container_overrides", &self.container_overrides);
        formatter.field("node_overrides", &self.node_overrides);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.field("propagate_tags", &self.propagate_tags);
        formatter.field("timeout", &self.timeout);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInputBody<'a> {
    /// <p>The tags that you apply to the resource to help you categorize and organize your resources. Each tag consists of
    /// a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS Resources</a> in <i>AWS General
    /// Reference</i>.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for TagResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>TerminateJob</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TerminateJobInputBody<'a> {
    /// <p>The AWS Batch job ID of the job to terminate.</p>
    pub job_id: &'a std::option::Option<std::string::String>,
    /// <p>A message to attach to the job that explains the reason for canceling it. This message is returned by future
    /// <a>DescribeJobs</a> operations on the job. This message is also recorded in the AWS Batch activity
    /// logs.</p>
    pub reason: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for TerminateJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TerminateJobInputBody");
        formatter.field("job_id", &self.job_id);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>UpdateComputeEnvironment</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateComputeEnvironmentInputBody<'a> {
    /// <p>The name or full Amazon Resource Name (ARN) of the compute environment to update.</p>
    pub compute_environment: &'a std::option::Option<std::string::String>,
    /// <p>The state of the compute environment. Compute environments in the <code>ENABLED</code> state can accept jobs
    /// from a queue and scale in or out automatically based on the workload demand of its associated queues.</p>
    /// <p>If the state is <code>ENABLED</code>, then the AWS Batch scheduler can attempt to place jobs from an associated
    /// job queue on the compute resources within the environment. If the compute environment is managed, then it can scale
    /// its instances out or in automatically, based on the job queue demand.</p>
    /// <p>If the state is <code>DISABLED</code>, then the AWS Batch scheduler doesn't attempt to place jobs within the
    /// environment. Jobs in a <code>STARTING</code> or <code>RUNNING</code> state continue to progress normally. Managed
    /// compute environments in the <code>DISABLED</code> state don't scale out. However, they scale in to
    /// <code>minvCpus</code> value after instances become idle.</p>
    pub state: &'a std::option::Option<crate::model::CeState>,
    /// <p>Details of the compute resources managed by the compute environment. Required for a managed compute environment.
    /// For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html">Compute
    /// Environments</a> in the <i>AWS Batch User Guide</i>.</p>
    pub compute_resources: &'a std::option::Option<crate::model::ComputeResourceUpdate>,
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf. For
    /// more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/service_IAM_role.html">AWS Batch service IAM
    /// role</a> in the <i>AWS Batch User Guide</i>.</p>
    /// <important>
    /// <p>If the compute environment has a service-linked role, it cannot be changed to use a regular IAM role. If the
    /// compute environment has a regular IAM role, it cannot be changed to use a service-linked role.</p>
    /// </important>
    /// <p>If your specified role has a path other than <code>/</code>, then you must either specify the full role ARN
    /// (this is recommended) or prefix the role name with the path.</p>
    /// <note>
    /// <p>Depending on how you created your AWS Batch service role, its ARN might contain the <code>service-role</code>
    /// path prefix. When you only specify the name of the service role, AWS Batch assumes that your ARN doesn't use the
    /// <code>service-role</code> path prefix. Because of this, we recommend that you specify the full ARN of your service
    /// role when you create compute environments.</p>
    /// </note>
    pub service_role: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateComputeEnvironmentInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateComputeEnvironmentInputBody");
        formatter.field("compute_environment", &self.compute_environment);
        formatter.field("state", &self.state);
        formatter.field("compute_resources", &self.compute_resources);
        formatter.field("service_role", &self.service_role);
        formatter.finish()
    }
}

/// <p>Contains the parameters for <code>UpdateJobQueue</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateJobQueueInputBody<'a> {
    /// <p>The name or the Amazon Resource Name (ARN) of the job queue.</p>
    pub job_queue: &'a std::option::Option<std::string::String>,
    /// <p>Describes the queue's ability to accept new jobs. If the job queue state is <code>ENABLED</code>, it can accept
    /// jobs. If the job queue state is <code>DISABLED</code>, new jobs can't be added to the queue, but jobs already in the
    /// queue can finish.</p>
    pub state: &'a std::option::Option<crate::model::JqState>,
    /// <p>The priority of the job queue. Job queues with a higher priority (or a higher integer value for the
    /// <code>priority</code> parameter) are evaluated first when associated with the same compute environment. Priority is
    /// determined in descending order, for example, a job queue with a priority value of <code>10</code> is given scheduling
    /// preference over a job queue with a priority value of <code>1</code>. All of the compute environments must be either
    /// EC2 (<code>EC2</code> or <code>SPOT</code>) or Fargate (<code>FARGATE</code> or <code>FARGATE_SPOT</code>). EC2 and
    /// Fargate compute environments can't be mixed.</p>
    pub priority: &'a i32,
    /// <p>Details the set of compute environments mapped to a job queue and their order relative to each other. This is
    /// one of the parameters used by the job scheduler to determine which compute environment should run a given job.
    /// Compute environments must be in the <code>VALID</code> state before you can associate them with a job queue. All of
    /// the compute environments must be either EC2 (<code>EC2</code> or <code>SPOT</code>) or Fargate
    /// (<code>FARGATE</code> or <code>FARGATE_SPOT</code>). EC2 and Fargate compute environments can't be mixed.</p>
    /// <note>
    /// <p>All compute environments that are associated with a job queue must share the same architecture. AWS Batch doesn't
    /// support mixing compute environment architecture types in a single job queue.</p>
    /// </note>
    pub compute_environment_order:
        &'a std::option::Option<std::vec::Vec<crate::model::ComputeEnvironmentOrder>>,
}
impl<'a> std::fmt::Debug for UpdateJobQueueInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateJobQueueInputBody");
        formatter.field("job_queue", &self.job_queue);
        formatter.field("state", &self.state);
        formatter.field("priority", &self.priority);
        formatter.field("compute_environment_order", &self.compute_environment_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateComputeEnvironmentOutputBody {
    /// <p>The name of the compute environment. Up to 128 letters (uppercase and lowercase), numbers, hyphens, and
    /// underscores are allowed.</p>
    #[serde(rename = "computeEnvironmentName")]
    #[serde(default)]
    pub compute_environment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the compute environment.</p>
    #[serde(rename = "computeEnvironmentArn")]
    #[serde(default)]
    pub compute_environment_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateComputeEnvironmentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateComputeEnvironmentOutputBody");
        formatter.field("compute_environment_name", &self.compute_environment_name);
        formatter.field("compute_environment_arn", &self.compute_environment_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateJobQueueOutputBody {
    /// <p>The name of the job queue.</p>
    #[serde(rename = "jobQueueName")]
    #[serde(default)]
    pub job_queue_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the job queue.</p>
    #[serde(rename = "jobQueueArn")]
    #[serde(default)]
    pub job_queue_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateJobQueueOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateJobQueueOutputBody");
        formatter.field("job_queue_name", &self.job_queue_name);
        formatter.field("job_queue_arn", &self.job_queue_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeComputeEnvironmentsOutputBody {
    /// <p>The list of compute environments.</p>
    #[serde(rename = "computeEnvironments")]
    #[serde(default)]
    pub compute_environments:
        std::option::Option<std::vec::Vec<crate::model::ComputeEnvironmentDetail>>,
    /// <p>The <code>nextToken</code> value to include in a future <code>DescribeComputeEnvironments</code> request. When
    /// the results of a <code>DescribeJobDefinitions</code> request exceed <code>maxResults</code>, this value can be used
    /// to retrieve the next page of results. This value is <code>null</code> when there are no more results to
    /// return.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeComputeEnvironmentsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeComputeEnvironmentsOutputBody");
        formatter.field("compute_environments", &self.compute_environments);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobDefinitionsOutputBody {
    /// <p>The list of job definitions.</p>
    #[serde(rename = "jobDefinitions")]
    #[serde(default)]
    pub job_definitions: std::option::Option<std::vec::Vec<crate::model::JobDefinition>>,
    /// <p>The <code>nextToken</code> value to include in a future <code>DescribeJobDefinitions</code> request. When the
    /// results of a <code>DescribeJobDefinitions</code> request exceed <code>maxResults</code>, this value can be used to
    /// retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeJobDefinitionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobDefinitionsOutputBody");
        formatter.field("job_definitions", &self.job_definitions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobQueuesOutputBody {
    /// <p>The list of job queues.</p>
    #[serde(rename = "jobQueues")]
    #[serde(default)]
    pub job_queues: std::option::Option<std::vec::Vec<crate::model::JobQueueDetail>>,
    /// <p>The <code>nextToken</code> value to include in a future <code>DescribeJobQueues</code> request. When the results
    /// of a <code>DescribeJobQueues</code> request exceed <code>maxResults</code>, this value can be used to retrieve the
    /// next page of results. This value is <code>null</code> when there are no more results to return.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeJobQueuesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobQueuesOutputBody");
        formatter.field("job_queues", &self.job_queues);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobsOutputBody {
    /// <p>The list of jobs.</p>
    #[serde(rename = "jobs")]
    #[serde(default)]
    pub jobs: std::option::Option<std::vec::Vec<crate::model::JobDetail>>,
}
impl std::fmt::Debug for DescribeJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobsOutputBody");
        formatter.field("jobs", &self.jobs);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobsOutputBody {
    /// <p>A list of job summaries that match the request.</p>
    #[serde(rename = "jobSummaryList")]
    #[serde(default)]
    pub job_summary_list: std::option::Option<std::vec::Vec<crate::model::JobSummary>>,
    /// <p>The <code>nextToken</code> value to include in a future <code>ListJobs</code> request. When the results of a
    /// <code>ListJobs</code> request exceed <code>maxResults</code>, this value can be used to retrieve the next page of
    /// results. This value is <code>null</code> when there are no more results to return.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobsOutputBody");
        formatter.field("job_summary_list", &self.job_summary_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutputBody {
    /// <p>The tags for the resource.</p>
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ListTagsForResourceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterJobDefinitionOutputBody {
    /// <p>The name of the job definition.</p>
    #[serde(rename = "jobDefinitionName")]
    #[serde(default)]
    pub job_definition_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the job definition.</p>
    #[serde(rename = "jobDefinitionArn")]
    #[serde(default)]
    pub job_definition_arn: std::option::Option<std::string::String>,
    /// <p>The revision of the job definition.</p>
    #[serde(rename = "revision")]
    #[serde(default)]
    pub revision: i32,
}
impl std::fmt::Debug for RegisterJobDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterJobDefinitionOutputBody");
        formatter.field("job_definition_name", &self.job_definition_name);
        formatter.field("job_definition_arn", &self.job_definition_arn);
        formatter.field("revision", &self.revision);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SubmitJobOutputBody {
    /// <p>The Amazon Resource Name (ARN) for the job.</p>
    #[serde(rename = "jobArn")]
    #[serde(default)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the job.</p>
    #[serde(rename = "jobName")]
    #[serde(default)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the job.</p>
    #[serde(rename = "jobId")]
    #[serde(default)]
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubmitJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubmitJobOutputBody");
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_name", &self.job_name);
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateComputeEnvironmentOutputBody {
    /// <p>The name of the compute environment. Up to 128 letters (uppercase and lowercase), numbers, hyphens, and
    /// underscores are allowed.</p>
    #[serde(rename = "computeEnvironmentName")]
    #[serde(default)]
    pub compute_environment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the compute environment.</p>
    #[serde(rename = "computeEnvironmentArn")]
    #[serde(default)]
    pub compute_environment_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateComputeEnvironmentOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateComputeEnvironmentOutputBody");
        formatter.field("compute_environment_name", &self.compute_environment_name);
        formatter.field("compute_environment_arn", &self.compute_environment_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateJobQueueOutputBody {
    /// <p>The name of the job queue.</p>
    #[serde(rename = "jobQueueName")]
    #[serde(default)]
    pub job_queue_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the job queue.</p>
    #[serde(rename = "jobQueueArn")]
    #[serde(default)]
    pub job_queue_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateJobQueueOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateJobQueueOutputBody");
        formatter.field("job_queue_name", &self.job_queue_name);
        formatter.field("job_queue_arn", &self.job_queue_arn);
        formatter.finish()
    }
}
