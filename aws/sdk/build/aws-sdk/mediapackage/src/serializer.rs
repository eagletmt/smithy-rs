// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// the option to configure log subscription.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigureLogsInputBody<'a> {
    /// Configure egress access logging.
    pub egress_access_logs: &'a std::option::Option<crate::model::EgressAccessLogs>,
    /// Configure ingress access logging.
    pub ingress_access_logs: &'a std::option::Option<crate::model::IngressAccessLogs>,
}
impl<'a> std::fmt::Debug for ConfigureLogsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigureLogsInputBody");
        formatter.field("egress_access_logs", &self.egress_access_logs);
        formatter.field("ingress_access_logs", &self.ingress_access_logs);
        formatter.finish()
    }
}

/// A new Channel configuration.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelInputBody<'a> {
    /// A short text description of the Channel.
    pub description: &'a std::option::Option<std::string::String>,
    /// The ID of the Channel. The ID must be unique within the region and it
    /// cannot be changed after a Channel is created.
    pub id: &'a std::option::Option<std::string::String>,
    /// A collection of tags associated with a resource
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for CreateChannelInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelInputBody");
        formatter.field("description", &self.description);
        formatter.field("id", &self.id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Configuration parameters used to create a new HarvestJob.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHarvestJobInputBody<'a> {
    /// The end of the time-window which will be harvested
    pub end_time: &'a std::option::Option<std::string::String>,
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted
    pub id: &'a std::option::Option<std::string::String>,
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    pub origin_endpoint_id: &'a std::option::Option<std::string::String>,
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    pub s3_destination: &'a std::option::Option<crate::model::S3Destination>,
    /// The start of the time-window which will be harvested
    pub start_time: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateHarvestJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHarvestJobInputBody");
        formatter.field("end_time", &self.end_time);
        formatter.field("id", &self.id);
        formatter.field("origin_endpoint_id", &self.origin_endpoint_id);
        formatter.field("s3_destination", &self.s3_destination);
        formatter.field("start_time", &self.start_time);
        formatter.finish()
    }
}

/// Configuration parameters used to create a new OriginEndpoint.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOriginEndpointInputBody<'a> {
    /// CDN Authorization credentials
    pub authorization: &'a std::option::Option<crate::model::Authorization>,
    /// The ID of the Channel that the OriginEndpoint will be associated with.
    /// This cannot be changed after the OriginEndpoint is created.
    pub channel_id: &'a std::option::Option<std::string::String>,
    /// A Common Media Application Format (CMAF) packaging configuration.
    pub cmaf_package: &'a std::option::Option<crate::model::CmafPackageCreateOrUpdateParameters>,
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    pub dash_package: &'a std::option::Option<crate::model::DashPackage>,
    /// A short text description of the OriginEndpoint.
    pub description: &'a std::option::Option<std::string::String>,
    /// An HTTP Live Streaming (HLS) packaging configuration.
    pub hls_package: &'a std::option::Option<crate::model::HlsPackage>,
    /// The ID of the OriginEndpoint.  The ID must be unique within the region
    /// and it cannot be changed after the OriginEndpoint is created.
    pub id: &'a std::option::Option<std::string::String>,
    /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
    pub manifest_name: &'a std::option::Option<std::string::String>,
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    pub mss_package: &'a std::option::Option<crate::model::MssPackage>,
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    pub origination: &'a std::option::Option<crate::model::Origination>,
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    pub startover_window_seconds: &'a i32,
    /// A collection of tags associated with a resource
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    pub time_delay_seconds: &'a i32,
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    pub whitelist: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for CreateOriginEndpointInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOriginEndpointInputBody");
        formatter.field("authorization", &self.authorization);
        formatter.field("channel_id", &self.channel_id);
        formatter.field("cmaf_package", &self.cmaf_package);
        formatter.field("dash_package", &self.dash_package);
        formatter.field("description", &self.description);
        formatter.field("hls_package", &self.hls_package);
        formatter.field("id", &self.id);
        formatter.field("manifest_name", &self.manifest_name);
        formatter.field("mss_package", &self.mss_package);
        formatter.field("origination", &self.origination);
        formatter.field("startover_window_seconds", &self.startover_window_seconds);
        formatter.field("tags", &self.tags);
        formatter.field("time_delay_seconds", &self.time_delay_seconds);
        formatter.field("whitelist", &self.whitelist);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInputBody<'a> {
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for TagResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// Configuration parameters used to update the Channel.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelInputBody<'a> {
    /// A short text description of the Channel.
    pub description: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateChannelInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelInputBody");
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

/// Configuration parameters used to update an existing OriginEndpoint.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateOriginEndpointInputBody<'a> {
    /// CDN Authorization credentials
    pub authorization: &'a std::option::Option<crate::model::Authorization>,
    /// A Common Media Application Format (CMAF) packaging configuration.
    pub cmaf_package: &'a std::option::Option<crate::model::CmafPackageCreateOrUpdateParameters>,
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    pub dash_package: &'a std::option::Option<crate::model::DashPackage>,
    /// A short text description of the OriginEndpoint.
    pub description: &'a std::option::Option<std::string::String>,
    /// An HTTP Live Streaming (HLS) packaging configuration.
    pub hls_package: &'a std::option::Option<crate::model::HlsPackage>,
    /// A short string that will be appended to the end of the Endpoint URL.
    pub manifest_name: &'a std::option::Option<std::string::String>,
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    pub mss_package: &'a std::option::Option<crate::model::MssPackage>,
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    pub origination: &'a std::option::Option<crate::model::Origination>,
    /// Maximum duration (in seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    pub startover_window_seconds: &'a i32,
    /// Amount of delay (in seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    pub time_delay_seconds: &'a i32,
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    pub whitelist: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UpdateOriginEndpointInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateOriginEndpointInputBody");
        formatter.field("authorization", &self.authorization);
        formatter.field("cmaf_package", &self.cmaf_package);
        formatter.field("dash_package", &self.dash_package);
        formatter.field("description", &self.description);
        formatter.field("hls_package", &self.hls_package);
        formatter.field("manifest_name", &self.manifest_name);
        formatter.field("mss_package", &self.mss_package);
        formatter.field("origination", &self.origination);
        formatter.field("startover_window_seconds", &self.startover_window_seconds);
        formatter.field("time_delay_seconds", &self.time_delay_seconds);
        formatter.field("whitelist", &self.whitelist);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigureLogsOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A short text description of the Channel.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// Configure egress access logging.
    #[serde(rename = "egressAccessLogs")]
    #[serde(default)]
    pub egress_access_logs: std::option::Option<crate::model::EgressAccessLogs>,
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    #[serde(rename = "hlsIngest")]
    #[serde(default)]
    pub hls_ingest: std::option::Option<crate::model::HlsIngest>,
    /// The ID of the Channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configure ingress access logging.
    #[serde(rename = "ingressAccessLogs")]
    #[serde(default)]
    pub ingress_access_logs: std::option::Option<crate::model::IngressAccessLogs>,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ConfigureLogsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigureLogsOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("egress_access_logs", &self.egress_access_logs);
        formatter.field("hls_ingest", &self.hls_ingest);
        formatter.field("id", &self.id);
        formatter.field("ingress_access_logs", &self.ingress_access_logs);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A short text description of the Channel.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// Configure egress access logging.
    #[serde(rename = "egressAccessLogs")]
    #[serde(default)]
    pub egress_access_logs: std::option::Option<crate::model::EgressAccessLogs>,
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    #[serde(rename = "hlsIngest")]
    #[serde(default)]
    pub hls_ingest: std::option::Option<crate::model::HlsIngest>,
    /// The ID of the Channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configure ingress access logging.
    #[serde(rename = "ingressAccessLogs")]
    #[serde(default)]
    pub ingress_access_logs: std::option::Option<crate::model::IngressAccessLogs>,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("egress_access_logs", &self.egress_access_logs);
        formatter.field("hls_ingest", &self.hls_ingest);
        formatter.field("id", &self.id);
        formatter.field("ingress_access_logs", &self.ingress_access_logs);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHarvestJobOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// The ID of the Channel that the HarvestJob will harvest from.
    #[serde(rename = "channelId")]
    #[serde(default)]
    pub channel_id: std::option::Option<std::string::String>,
    /// The time the HarvestJob was submitted
    #[serde(rename = "createdAt")]
    #[serde(default)]
    pub created_at: std::option::Option<std::string::String>,
    /// The end of the time-window which will be harvested.
    #[serde(rename = "endTime")]
    #[serde(default)]
    pub end_time: std::option::Option<std::string::String>,
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    #[serde(rename = "originEndpointId")]
    #[serde(default)]
    pub origin_endpoint_id: std::option::Option<std::string::String>,
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    #[serde(rename = "s3Destination")]
    #[serde(default)]
    pub s3_destination: std::option::Option<crate::model::S3Destination>,
    /// The start of the time-window which will be harvested.
    #[serde(rename = "startTime")]
    #[serde(default)]
    pub start_time: std::option::Option<std::string::String>,
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
    /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
    /// include an explanation of why the HarvestJob failed.
    #[serde(rename = "status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::Status>,
}
impl std::fmt::Debug for CreateHarvestJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHarvestJobOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("channel_id", &self.channel_id);
        formatter.field("created_at", &self.created_at);
        formatter.field("end_time", &self.end_time);
        formatter.field("id", &self.id);
        formatter.field("origin_endpoint_id", &self.origin_endpoint_id);
        formatter.field("s3_destination", &self.s3_destination);
        formatter.field("start_time", &self.start_time);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOriginEndpointOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// CDN Authorization credentials
    #[serde(rename = "authorization")]
    #[serde(default)]
    pub authorization: std::option::Option<crate::model::Authorization>,
    /// The ID of the Channel the OriginEndpoint is associated with.
    #[serde(rename = "channelId")]
    #[serde(default)]
    pub channel_id: std::option::Option<std::string::String>,
    /// A Common Media Application Format (CMAF) packaging configuration.
    #[serde(rename = "cmafPackage")]
    #[serde(default)]
    pub cmaf_package: std::option::Option<crate::model::CmafPackage>,
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    #[serde(rename = "dashPackage")]
    #[serde(default)]
    pub dash_package: std::option::Option<crate::model::DashPackage>,
    /// A short text description of the OriginEndpoint.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// An HTTP Live Streaming (HLS) packaging configuration.
    #[serde(rename = "hlsPackage")]
    #[serde(default)]
    pub hls_package: std::option::Option<crate::model::HlsPackage>,
    /// The ID of the OriginEndpoint.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// A short string appended to the end of the OriginEndpoint URL.
    #[serde(rename = "manifestName")]
    #[serde(default)]
    pub manifest_name: std::option::Option<std::string::String>,
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    #[serde(rename = "mssPackage")]
    #[serde(default)]
    pub mss_package: std::option::Option<crate::model::MssPackage>,
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    #[serde(rename = "origination")]
    #[serde(default)]
    pub origination: std::option::Option<crate::model::Origination>,
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    #[serde(rename = "startoverWindowSeconds")]
    #[serde(default)]
    pub startover_window_seconds: i32,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    #[serde(rename = "timeDelaySeconds")]
    #[serde(default)]
    pub time_delay_seconds: i32,
    /// The URL of the packaged OriginEndpoint for consumption.
    #[serde(rename = "url")]
    #[serde(default)]
    pub url: std::option::Option<std::string::String>,
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    #[serde(rename = "whitelist")]
    #[serde(default)]
    pub whitelist: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for CreateOriginEndpointOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOriginEndpointOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("authorization", &self.authorization);
        formatter.field("channel_id", &self.channel_id);
        formatter.field("cmaf_package", &self.cmaf_package);
        formatter.field("dash_package", &self.dash_package);
        formatter.field("description", &self.description);
        formatter.field("hls_package", &self.hls_package);
        formatter.field("id", &self.id);
        formatter.field("manifest_name", &self.manifest_name);
        formatter.field("mss_package", &self.mss_package);
        formatter.field("origination", &self.origination);
        formatter.field("startover_window_seconds", &self.startover_window_seconds);
        formatter.field("tags", &self.tags);
        formatter.field("time_delay_seconds", &self.time_delay_seconds);
        formatter.field("url", &self.url);
        formatter.field("whitelist", &self.whitelist);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A short text description of the Channel.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// Configure egress access logging.
    #[serde(rename = "egressAccessLogs")]
    #[serde(default)]
    pub egress_access_logs: std::option::Option<crate::model::EgressAccessLogs>,
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    #[serde(rename = "hlsIngest")]
    #[serde(default)]
    pub hls_ingest: std::option::Option<crate::model::HlsIngest>,
    /// The ID of the Channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configure ingress access logging.
    #[serde(rename = "ingressAccessLogs")]
    #[serde(default)]
    pub ingress_access_logs: std::option::Option<crate::model::IngressAccessLogs>,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DescribeChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("egress_access_logs", &self.egress_access_logs);
        formatter.field("hls_ingest", &self.hls_ingest);
        formatter.field("id", &self.id);
        formatter.field("ingress_access_logs", &self.ingress_access_logs);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeHarvestJobOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// The ID of the Channel that the HarvestJob will harvest from.
    #[serde(rename = "channelId")]
    #[serde(default)]
    pub channel_id: std::option::Option<std::string::String>,
    /// The time the HarvestJob was submitted
    #[serde(rename = "createdAt")]
    #[serde(default)]
    pub created_at: std::option::Option<std::string::String>,
    /// The end of the time-window which will be harvested.
    #[serde(rename = "endTime")]
    #[serde(default)]
    pub end_time: std::option::Option<std::string::String>,
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    #[serde(rename = "originEndpointId")]
    #[serde(default)]
    pub origin_endpoint_id: std::option::Option<std::string::String>,
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    #[serde(rename = "s3Destination")]
    #[serde(default)]
    pub s3_destination: std::option::Option<crate::model::S3Destination>,
    /// The start of the time-window which will be harvested.
    #[serde(rename = "startTime")]
    #[serde(default)]
    pub start_time: std::option::Option<std::string::String>,
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
    /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
    /// include an explanation of why the HarvestJob failed.
    #[serde(rename = "status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::Status>,
}
impl std::fmt::Debug for DescribeHarvestJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeHarvestJobOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("channel_id", &self.channel_id);
        formatter.field("created_at", &self.created_at);
        formatter.field("end_time", &self.end_time);
        formatter.field("id", &self.id);
        formatter.field("origin_endpoint_id", &self.origin_endpoint_id);
        formatter.field("s3_destination", &self.s3_destination);
        formatter.field("start_time", &self.start_time);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeOriginEndpointOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// CDN Authorization credentials
    #[serde(rename = "authorization")]
    #[serde(default)]
    pub authorization: std::option::Option<crate::model::Authorization>,
    /// The ID of the Channel the OriginEndpoint is associated with.
    #[serde(rename = "channelId")]
    #[serde(default)]
    pub channel_id: std::option::Option<std::string::String>,
    /// A Common Media Application Format (CMAF) packaging configuration.
    #[serde(rename = "cmafPackage")]
    #[serde(default)]
    pub cmaf_package: std::option::Option<crate::model::CmafPackage>,
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    #[serde(rename = "dashPackage")]
    #[serde(default)]
    pub dash_package: std::option::Option<crate::model::DashPackage>,
    /// A short text description of the OriginEndpoint.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// An HTTP Live Streaming (HLS) packaging configuration.
    #[serde(rename = "hlsPackage")]
    #[serde(default)]
    pub hls_package: std::option::Option<crate::model::HlsPackage>,
    /// The ID of the OriginEndpoint.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// A short string appended to the end of the OriginEndpoint URL.
    #[serde(rename = "manifestName")]
    #[serde(default)]
    pub manifest_name: std::option::Option<std::string::String>,
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    #[serde(rename = "mssPackage")]
    #[serde(default)]
    pub mss_package: std::option::Option<crate::model::MssPackage>,
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    #[serde(rename = "origination")]
    #[serde(default)]
    pub origination: std::option::Option<crate::model::Origination>,
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    #[serde(rename = "startoverWindowSeconds")]
    #[serde(default)]
    pub startover_window_seconds: i32,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    #[serde(rename = "timeDelaySeconds")]
    #[serde(default)]
    pub time_delay_seconds: i32,
    /// The URL of the packaged OriginEndpoint for consumption.
    #[serde(rename = "url")]
    #[serde(default)]
    pub url: std::option::Option<std::string::String>,
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    #[serde(rename = "whitelist")]
    #[serde(default)]
    pub whitelist: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DescribeOriginEndpointOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeOriginEndpointOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("authorization", &self.authorization);
        formatter.field("channel_id", &self.channel_id);
        formatter.field("cmaf_package", &self.cmaf_package);
        formatter.field("dash_package", &self.dash_package);
        formatter.field("description", &self.description);
        formatter.field("hls_package", &self.hls_package);
        formatter.field("id", &self.id);
        formatter.field("manifest_name", &self.manifest_name);
        formatter.field("mss_package", &self.mss_package);
        formatter.field("origination", &self.origination);
        formatter.field("startover_window_seconds", &self.startover_window_seconds);
        formatter.field("tags", &self.tags);
        formatter.field("time_delay_seconds", &self.time_delay_seconds);
        formatter.field("url", &self.url);
        formatter.field("whitelist", &self.whitelist);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsOutputBody {
    /// A list of Channel records.
    #[serde(rename = "channels")]
    #[serde(default)]
    pub channels: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// A token that can be used to resume pagination from the end of the collection.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsOutputBody");
        formatter.field("channels", &self.channels);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListHarvestJobsOutputBody {
    /// A list of HarvestJob records.
    #[serde(rename = "harvestJobs")]
    #[serde(default)]
    pub harvest_jobs: std::option::Option<std::vec::Vec<crate::model::HarvestJob>>,
    /// A token that can be used to resume pagination from the end of the collection.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListHarvestJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListHarvestJobsOutputBody");
        formatter.field("harvest_jobs", &self.harvest_jobs);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOriginEndpointsOutputBody {
    /// A token that can be used to resume pagination from the end of the collection.
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// A list of OriginEndpoint records.
    #[serde(rename = "originEndpoints")]
    #[serde(default)]
    pub origin_endpoints: std::option::Option<std::vec::Vec<crate::model::OriginEndpoint>>,
}
impl std::fmt::Debug for ListOriginEndpointsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOriginEndpointsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("origin_endpoints", &self.origin_endpoints);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutputBody {
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ListTagsForResourceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RotateChannelCredentialsOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A short text description of the Channel.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// Configure egress access logging.
    #[serde(rename = "egressAccessLogs")]
    #[serde(default)]
    pub egress_access_logs: std::option::Option<crate::model::EgressAccessLogs>,
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    #[serde(rename = "hlsIngest")]
    #[serde(default)]
    pub hls_ingest: std::option::Option<crate::model::HlsIngest>,
    /// The ID of the Channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configure ingress access logging.
    #[serde(rename = "ingressAccessLogs")]
    #[serde(default)]
    pub ingress_access_logs: std::option::Option<crate::model::IngressAccessLogs>,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for RotateChannelCredentialsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RotateChannelCredentialsOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("egress_access_logs", &self.egress_access_logs);
        formatter.field("hls_ingest", &self.hls_ingest);
        formatter.field("id", &self.id);
        formatter.field("ingress_access_logs", &self.ingress_access_logs);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RotateIngestEndpointCredentialsOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A short text description of the Channel.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// Configure egress access logging.
    #[serde(rename = "egressAccessLogs")]
    #[serde(default)]
    pub egress_access_logs: std::option::Option<crate::model::EgressAccessLogs>,
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    #[serde(rename = "hlsIngest")]
    #[serde(default)]
    pub hls_ingest: std::option::Option<crate::model::HlsIngest>,
    /// The ID of the Channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configure ingress access logging.
    #[serde(rename = "ingressAccessLogs")]
    #[serde(default)]
    pub ingress_access_logs: std::option::Option<crate::model::IngressAccessLogs>,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for RotateIngestEndpointCredentialsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RotateIngestEndpointCredentialsOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("egress_access_logs", &self.egress_access_logs);
        formatter.field("hls_ingest", &self.hls_ingest);
        formatter.field("id", &self.id);
        formatter.field("ingress_access_logs", &self.ingress_access_logs);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// A short text description of the Channel.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// Configure egress access logging.
    #[serde(rename = "egressAccessLogs")]
    #[serde(default)]
    pub egress_access_logs: std::option::Option<crate::model::EgressAccessLogs>,
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    #[serde(rename = "hlsIngest")]
    #[serde(default)]
    pub hls_ingest: std::option::Option<crate::model::HlsIngest>,
    /// The ID of the Channel.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// Configure ingress access logging.
    #[serde(rename = "ingressAccessLogs")]
    #[serde(default)]
    pub ingress_access_logs: std::option::Option<crate::model::IngressAccessLogs>,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for UpdateChannelOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("egress_access_logs", &self.egress_access_logs);
        formatter.field("hls_ingest", &self.hls_ingest);
        formatter.field("id", &self.id);
        formatter.field("ingress_access_logs", &self.ingress_access_logs);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateOriginEndpointOutputBody {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    #[serde(rename = "arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// CDN Authorization credentials
    #[serde(rename = "authorization")]
    #[serde(default)]
    pub authorization: std::option::Option<crate::model::Authorization>,
    /// The ID of the Channel the OriginEndpoint is associated with.
    #[serde(rename = "channelId")]
    #[serde(default)]
    pub channel_id: std::option::Option<std::string::String>,
    /// A Common Media Application Format (CMAF) packaging configuration.
    #[serde(rename = "cmafPackage")]
    #[serde(default)]
    pub cmaf_package: std::option::Option<crate::model::CmafPackage>,
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    #[serde(rename = "dashPackage")]
    #[serde(default)]
    pub dash_package: std::option::Option<crate::model::DashPackage>,
    /// A short text description of the OriginEndpoint.
    #[serde(rename = "description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// An HTTP Live Streaming (HLS) packaging configuration.
    #[serde(rename = "hlsPackage")]
    #[serde(default)]
    pub hls_package: std::option::Option<crate::model::HlsPackage>,
    /// The ID of the OriginEndpoint.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: std::option::Option<std::string::String>,
    /// A short string appended to the end of the OriginEndpoint URL.
    #[serde(rename = "manifestName")]
    #[serde(default)]
    pub manifest_name: std::option::Option<std::string::String>,
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    #[serde(rename = "mssPackage")]
    #[serde(default)]
    pub mss_package: std::option::Option<crate::model::MssPackage>,
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    #[serde(rename = "origination")]
    #[serde(default)]
    pub origination: std::option::Option<crate::model::Origination>,
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    #[serde(rename = "startoverWindowSeconds")]
    #[serde(default)]
    pub startover_window_seconds: i32,
    /// A collection of tags associated with a resource
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    #[serde(rename = "timeDelaySeconds")]
    #[serde(default)]
    pub time_delay_seconds: i32,
    /// The URL of the packaged OriginEndpoint for consumption.
    #[serde(rename = "url")]
    #[serde(default)]
    pub url: std::option::Option<std::string::String>,
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    #[serde(rename = "whitelist")]
    #[serde(default)]
    pub whitelist: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UpdateOriginEndpointOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateOriginEndpointOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("authorization", &self.authorization);
        formatter.field("channel_id", &self.channel_id);
        formatter.field("cmaf_package", &self.cmaf_package);
        formatter.field("dash_package", &self.dash_package);
        formatter.field("description", &self.description);
        formatter.field("hls_package", &self.hls_package);
        formatter.field("id", &self.id);
        formatter.field("manifest_name", &self.manifest_name);
        formatter.field("mss_package", &self.mss_package);
        formatter.field("origination", &self.origination);
        formatter.field("startover_window_seconds", &self.startover_window_seconds);
        formatter.field("tags", &self.tags);
        formatter.field("time_delay_seconds", &self.time_delay_seconds);
        formatter.field("url", &self.url);
        formatter.field("whitelist", &self.whitelist);
        formatter.finish()
    }
}
