// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    EngineNotSupportedError(crate::error::EngineNotSupportedError),
    InvalidLexiconError(crate::error::InvalidLexiconError),
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    InvalidS3BucketError(crate::error::InvalidS3BucketError),
    InvalidS3KeyError(crate::error::InvalidS3KeyError),
    InvalidSampleRateError(crate::error::InvalidSampleRateError),
    InvalidSnsTopicArnError(crate::error::InvalidSnsTopicArnError),
    InvalidSsmlError(crate::error::InvalidSsmlError),
    InvalidTaskIdError(crate::error::InvalidTaskIdError),
    LanguageNotSupportedError(crate::error::LanguageNotSupportedError),
    LexiconNotFoundError(crate::error::LexiconNotFoundError),
    LexiconSizeExceededError(crate::error::LexiconSizeExceededError),
    MarksNotSupportedForFormatError(crate::error::MarksNotSupportedForFormatError),
    MaxLexemeLengthExceededError(crate::error::MaxLexemeLengthExceededError),
    MaxLexiconsNumberExceededError(crate::error::MaxLexiconsNumberExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    SsmlMarksNotSupportedForTextTypeError(crate::error::SsmlMarksNotSupportedForTextTypeError),
    SynthesisTaskNotFoundError(crate::error::SynthesisTaskNotFoundError),
    TextLengthExceededError(crate::error::TextLengthExceededError),
    UnsupportedPlsAlphabetError(crate::error::UnsupportedPlsAlphabetError),
    UnsupportedPlsLanguageError(crate::error::UnsupportedPlsLanguageError),
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::EngineNotSupportedError(inner) => inner.fmt(f),
            Error::InvalidLexiconError(inner) => inner.fmt(f),
            Error::InvalidNextTokenError(inner) => inner.fmt(f),
            Error::InvalidS3BucketError(inner) => inner.fmt(f),
            Error::InvalidS3KeyError(inner) => inner.fmt(f),
            Error::InvalidSampleRateError(inner) => inner.fmt(f),
            Error::InvalidSnsTopicArnError(inner) => inner.fmt(f),
            Error::InvalidSsmlError(inner) => inner.fmt(f),
            Error::InvalidTaskIdError(inner) => inner.fmt(f),
            Error::LanguageNotSupportedError(inner) => inner.fmt(f),
            Error::LexiconNotFoundError(inner) => inner.fmt(f),
            Error::LexiconSizeExceededError(inner) => inner.fmt(f),
            Error::MarksNotSupportedForFormatError(inner) => inner.fmt(f),
            Error::MaxLexemeLengthExceededError(inner) => inner.fmt(f),
            Error::MaxLexiconsNumberExceededError(inner) => inner.fmt(f),
            Error::ServiceFailureError(inner) => inner.fmt(f),
            Error::SsmlMarksNotSupportedForTextTypeError(inner) => inner.fmt(f),
            Error::SynthesisTaskNotFoundError(inner) => inner.fmt(f),
            Error::TextLengthExceededError(inner) => inner.fmt(f),
            Error::UnsupportedPlsAlphabetError(inner) => inner.fmt(f),
            Error::UnsupportedPlsLanguageError(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::DeleteLexiconError>> for Error {
    fn from(err: smithy_http::result::SdkError<crate::error::DeleteLexiconError>) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::DeleteLexiconErrorKind::LexiconNotFoundError(inner) => {
                    Error::LexiconNotFoundError(inner)
                }
                crate::error::DeleteLexiconErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::DeleteLexiconErrorKind::Unhandled(inner) => Error::Unhandled(inner),
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::DescribeVoicesError>> for Error {
    fn from(err: smithy_http::result::SdkError<crate::error::DescribeVoicesError>) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::DescribeVoicesErrorKind::InvalidNextTokenError(inner) => {
                    Error::InvalidNextTokenError(inner)
                }
                crate::error::DescribeVoicesErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::DescribeVoicesErrorKind::Unhandled(inner) => Error::Unhandled(inner),
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::GetLexiconError>> for Error {
    fn from(err: smithy_http::result::SdkError<crate::error::GetLexiconError>) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::GetLexiconErrorKind::LexiconNotFoundError(inner) => {
                    Error::LexiconNotFoundError(inner)
                }
                crate::error::GetLexiconErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::GetLexiconErrorKind::Unhandled(inner) => Error::Unhandled(inner),
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::GetSpeechSynthesisTaskError>> for Error {
    fn from(err: smithy_http::result::SdkError<crate::error::GetSpeechSynthesisTaskError>) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::GetSpeechSynthesisTaskErrorKind::InvalidTaskIdError(inner) => {
                    Error::InvalidTaskIdError(inner)
                }
                crate::error::GetSpeechSynthesisTaskErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::GetSpeechSynthesisTaskErrorKind::SynthesisTaskNotFoundError(
                    inner,
                ) => Error::SynthesisTaskNotFoundError(inner),
                crate::error::GetSpeechSynthesisTaskErrorKind::Unhandled(inner) => {
                    Error::Unhandled(inner)
                }
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::ListLexiconsError>> for Error {
    fn from(err: smithy_http::result::SdkError<crate::error::ListLexiconsError>) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::ListLexiconsErrorKind::InvalidNextTokenError(inner) => {
                    Error::InvalidNextTokenError(inner)
                }
                crate::error::ListLexiconsErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::ListLexiconsErrorKind::Unhandled(inner) => Error::Unhandled(inner),
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::ListSpeechSynthesisTasksError>> for Error {
    fn from(
        err: smithy_http::result::SdkError<crate::error::ListSpeechSynthesisTasksError>,
    ) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::ListSpeechSynthesisTasksErrorKind::InvalidNextTokenError(inner) => {
                    Error::InvalidNextTokenError(inner)
                }
                crate::error::ListSpeechSynthesisTasksErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::ListSpeechSynthesisTasksErrorKind::Unhandled(inner) => {
                    Error::Unhandled(inner)
                }
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::PutLexiconError>> for Error {
    fn from(err: smithy_http::result::SdkError<crate::error::PutLexiconError>) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::PutLexiconErrorKind::InvalidLexiconError(inner) => {
                    Error::InvalidLexiconError(inner)
                }
                crate::error::PutLexiconErrorKind::LexiconSizeExceededError(inner) => {
                    Error::LexiconSizeExceededError(inner)
                }
                crate::error::PutLexiconErrorKind::MaxLexemeLengthExceededError(inner) => {
                    Error::MaxLexemeLengthExceededError(inner)
                }
                crate::error::PutLexiconErrorKind::MaxLexiconsNumberExceededError(inner) => {
                    Error::MaxLexiconsNumberExceededError(inner)
                }
                crate::error::PutLexiconErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::PutLexiconErrorKind::UnsupportedPlsAlphabetError(inner) => {
                    Error::UnsupportedPlsAlphabetError(inner)
                }
                crate::error::PutLexiconErrorKind::UnsupportedPlsLanguageError(inner) => {
                    Error::UnsupportedPlsLanguageError(inner)
                }
                crate::error::PutLexiconErrorKind::Unhandled(inner) => Error::Unhandled(inner),
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::StartSpeechSynthesisTaskError>> for Error {
    fn from(
        err: smithy_http::result::SdkError<crate::error::StartSpeechSynthesisTaskError>,
    ) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, ..} => match err.kind {
                crate::error::StartSpeechSynthesisTaskErrorKind::EngineNotSupportedError(inner) => Error::EngineNotSupportedError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::InvalidS3BucketError(inner) => Error::InvalidS3BucketError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::InvalidS3KeyError(inner) => Error::InvalidS3KeyError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::InvalidSampleRateError(inner) => Error::InvalidSampleRateError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::InvalidSnsTopicArnError(inner) => Error::InvalidSnsTopicArnError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::InvalidSsmlError(inner) => Error::InvalidSsmlError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::LanguageNotSupportedError(inner) => Error::LanguageNotSupportedError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::LexiconNotFoundError(inner) => Error::LexiconNotFoundError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::MarksNotSupportedForFormatError(inner) => Error::MarksNotSupportedForFormatError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::ServiceFailureError(inner) => Error::ServiceFailureError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::SsmlMarksNotSupportedForTextTypeError(inner) => Error::SsmlMarksNotSupportedForTextTypeError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::TextLengthExceededError(inner) => Error::TextLengthExceededError(inner),
                crate::error::StartSpeechSynthesisTaskErrorKind::Unhandled(inner) => Error::Unhandled(inner),
            }
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl From<smithy_http::result::SdkError<crate::error::SynthesizeSpeechError>> for Error {
    fn from(err: smithy_http::result::SdkError<crate::error::SynthesizeSpeechError>) -> Self {
        match err {
            smithy_http::result::SdkError::ServiceError { err, .. } => match err.kind {
                crate::error::SynthesizeSpeechErrorKind::EngineNotSupportedError(inner) => {
                    Error::EngineNotSupportedError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::InvalidSampleRateError(inner) => {
                    Error::InvalidSampleRateError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::InvalidSsmlError(inner) => {
                    Error::InvalidSsmlError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::LanguageNotSupportedError(inner) => {
                    Error::LanguageNotSupportedError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::LexiconNotFoundError(inner) => {
                    Error::LexiconNotFoundError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::MarksNotSupportedForFormatError(inner) => {
                    Error::MarksNotSupportedForFormatError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::ServiceFailureError(inner) => {
                    Error::ServiceFailureError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::SsmlMarksNotSupportedForTextTypeError(
                    inner,
                ) => Error::SsmlMarksNotSupportedForTextTypeError(inner),
                crate::error::SynthesizeSpeechErrorKind::TextLengthExceededError(inner) => {
                    Error::TextLengthExceededError(inner)
                }
                crate::error::SynthesizeSpeechErrorKind::Unhandled(inner) => {
                    Error::Unhandled(inner)
                }
            },
            _ => Error::Unhandled(err.into()),
        }
    }
}
impl std::error::Error for Error {}
