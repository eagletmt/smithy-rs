// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn serialize_operation_add_tags_to_stream_input_body(
    input: &crate::input::AddTagsToStreamInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::AddTagsToStreamInputBody {
        tags: &input.tags,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_create_stream_input_body(
    input: &crate::input::CreateStreamInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::CreateStreamInputBody {
        stream_name: &input.stream_name,
        shard_count: &input.shard_count,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_decrease_stream_retention_period_input_body(
    input: &crate::input::DecreaseStreamRetentionPeriodInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::DecreaseStreamRetentionPeriodInputBody {
        retention_period_hours: &input.retention_period_hours,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_delete_stream_input_body(
    input: &crate::input::DeleteStreamInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::DeleteStreamInputBody {
        stream_name: &input.stream_name,
        enforce_consumer_deletion: &input.enforce_consumer_deletion,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_deregister_stream_consumer_input_body(
    input: &crate::input::DeregisterStreamConsumerInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::DeregisterStreamConsumerInputBody {
        stream_arn: &input.stream_arn,
        consumer_name: &input.consumer_name,
        consumer_arn: &input.consumer_arn,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_describe_stream_input_body(
    input: &crate::input::DescribeStreamInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::DescribeStreamInputBody {
        stream_name: &input.stream_name,
        exclusive_start_shard_id: &input.exclusive_start_shard_id,
        limit: &input.limit,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_describe_stream_consumer_input_body(
    input: &crate::input::DescribeStreamConsumerInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::DescribeStreamConsumerInputBody {
        stream_arn: &input.stream_arn,
        consumer_name: &input.consumer_name,
        consumer_arn: &input.consumer_arn,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_describe_stream_summary_input_body(
    input: &crate::input::DescribeStreamSummaryInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::DescribeStreamSummaryInputBody {
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_disable_enhanced_monitoring_input_body(
    input: &crate::input::DisableEnhancedMonitoringInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::DisableEnhancedMonitoringInputBody {
        shard_level_metrics: &input.shard_level_metrics,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_enable_enhanced_monitoring_input_body(
    input: &crate::input::EnableEnhancedMonitoringInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::EnableEnhancedMonitoringInputBody {
        stream_name: &input.stream_name,
        shard_level_metrics: &input.shard_level_metrics,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_get_records_input_body(
    input: &crate::input::GetRecordsInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::GetRecordsInputBody {
        shard_iterator: &input.shard_iterator,
        limit: &input.limit,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_get_shard_iterator_input_body(
    input: &crate::input::GetShardIteratorInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::GetShardIteratorInputBody {
        shard_iterator_type: &input.shard_iterator_type,
        shard_id: &input.shard_id,
        starting_sequence_number: &input.starting_sequence_number,
        timestamp: &input.timestamp,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_increase_stream_retention_period_input_body(
    input: &crate::input::IncreaseStreamRetentionPeriodInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::IncreaseStreamRetentionPeriodInputBody {
        retention_period_hours: &input.retention_period_hours,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_list_shards_input_body(
    input: &crate::input::ListShardsInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::ListShardsInputBody {
        max_results: &input.max_results,
        stream_creation_timestamp: &input.stream_creation_timestamp,
        next_token: &input.next_token,
        exclusive_start_shard_id: &input.exclusive_start_shard_id,
        shard_filter: &input.shard_filter,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_list_stream_consumers_input_body(
    input: &crate::input::ListStreamConsumersInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::ListStreamConsumersInputBody {
        next_token: &input.next_token,
        stream_creation_timestamp: &input.stream_creation_timestamp,
        stream_arn: &input.stream_arn,
        max_results: &input.max_results,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_list_streams_input_body(
    input: &crate::input::ListStreamsInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::ListStreamsInputBody {
        limit: &input.limit,
        exclusive_start_stream_name: &input.exclusive_start_stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_list_tags_for_stream_input_body(
    input: &crate::input::ListTagsForStreamInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::ListTagsForStreamInputBody {
        limit: &input.limit,
        exclusive_start_tag_key: &input.exclusive_start_tag_key,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_merge_shards_input_body(
    input: &crate::input::MergeShardsInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::MergeShardsInputBody {
        adjacent_shard_to_merge: &input.adjacent_shard_to_merge,
        stream_name: &input.stream_name,
        shard_to_merge: &input.shard_to_merge,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_put_record_input_body(
    input: &crate::input::PutRecordInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::PutRecordInputBody {
        stream_name: &input.stream_name,
        explicit_hash_key: &input.explicit_hash_key,
        sequence_number_for_ordering: &input.sequence_number_for_ordering,
        partition_key: &input.partition_key,
        data: &input.data,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_put_records_input_body(
    input: &crate::input::PutRecordsInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::PutRecordsInputBody {
        records: &input.records,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_register_stream_consumer_input_body(
    input: &crate::input::RegisterStreamConsumerInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::RegisterStreamConsumerInputBody {
        consumer_name: &input.consumer_name,
        stream_arn: &input.stream_arn,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_remove_tags_from_stream_input_body(
    input: &crate::input::RemoveTagsFromStreamInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::RemoveTagsFromStreamInputBody {
        tag_keys: &input.tag_keys,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_split_shard_input_body(
    input: &crate::input::SplitShardInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::SplitShardInputBody {
        shard_to_split: &input.shard_to_split,
        new_starting_hash_key: &input.new_starting_hash_key,
        stream_name: &input.stream_name,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_start_stream_encryption_input_body(
    input: &crate::input::StartStreamEncryptionInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::StartStreamEncryptionInputBody {
        stream_name: &input.stream_name,
        encryption_type: &input.encryption_type,
        key_id: &input.key_id,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_stop_stream_encryption_input_body(
    input: &crate::input::StopStreamEncryptionInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::StopStreamEncryptionInputBody {
        stream_name: &input.stream_name,
        encryption_type: &input.encryption_type,
        key_id: &input.key_id,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}

pub fn serialize_operation_update_shard_count_input_body(
    input: &crate::input::UpdateShardCountInput,
) -> Result<smithy_http::body::SdkBody, serde_json::error::Error> {
    let body = crate::serializer::UpdateShardCountInputBody {
        scaling_type: &input.scaling_type,
        stream_name: &input.stream_name,
        target_shard_count: &input.target_shard_count,
    };
    serde_json::to_vec(&body).map(smithy_http::body::SdkBody::from)
}
